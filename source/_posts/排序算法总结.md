---
title: 排序算法总结
date: 2017-08-28 15:35:45
tags: 算法
---

### 直接插入排序
算法实现过程：筛选过程通过一个从右到左的循环实现，该循环使用变量j跟踪被筛选的元素。只要该元素具有前驱（j>0）且没有达到最终位置，循环就交换该元素和它的前驱，代码实现如下：
```java
public static void InsertSort(Integer[] a){
    for (int i = 1; i < a.length; i++) {
        for(int j = i; j > 0 && a[j-1]>a[j]; j--){
            int temp = a[j];
            a[j] = a[j-1];
            a[j-1] = temp;
        }
    }
}
```
算法分析：
- 给定待排序的数列初态不同时，直接插入排序所耗费的时间有很大差异。
- 若初态为正序，则每个待插入的记录只需比较一次就能找到对应位置插入，此时算法的时间复杂度为O(n)。
- 若初态为反序，则第i个待插入记录需要比较i+1次才能找到合适位置插入，此时时间复杂度为O(n^2)。

<!--more-->
### 二分插入排序
基本思想：二分法插入排序的思想和直接插入一样，只是找合适的插入位置的方式不同，这里通过二分法找到合适的位置，可以减少比较的次数。
```java
public static void BinaryInsertSort(Integer[] a){
    for(int i = 1; i < a.length; i++){
        int left = 0;
        int right = i-1;
        int mid;
        while(left<=right){
            mid = (left+right)/2;
            if(a[i] > a[mid])
                left = mid+1;
            else
                right = mid-1;
        }
        for(int j = i; j >= left; j--){
            int temp = a[j];
            a[j] = a[j-1];
            a[j-1] = temp;
        }
    }
}
```
算法分析：
- 二分插入排序的比较次数与待排序记录的初始状态无关，仅依赖记录的个数。
- 当n较大时，比直接插入排序的最大比较次数少得多，但大于直接插入排序的最小比较次数。

### 希尔排序
基本思想：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2<d1重复上述的分组和排序，直至所取的增量dt=1(dt<dt-l<…<d2<d1)，即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入排序。
```java
 public static void ShellSort(Integer[] nums){
    int d = nums.length;
    while(d > 1){
        d = d/2;
        for(int i = 0;i < d;i++){
            for(int j = i+d;j < nums.length;j = j+d){
                for(int k = j; k > i && nums[k] < nums[k-d];k = k -d){
                    int temp = nums[k];
                    nums[k] = nums[k-d];
                    nums[k-d] = temp;
                }
            }
        }
    }
}
```
希尔排序的时间性能优于直接插入排序，原因如下：
* 当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。
* 当n值较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0(n2)差别不大。
* 在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。

### 直接选择排序
算法思想：每趟从待排序的记录序列中选择关键字最小的记录放置到已排序表的最前位置，直到全部排完。时间复杂度为O(n^2)。
```java
public static void SelectSort(Integer[] nums){
    for(int i = 0;i < nums.length;i++){
        for(int j = i+1; j < nums.length;j++){
            if(nums[j] < nums[i]){
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
    }
}
```
### 堆排序
堆排序算法是一个两阶段的过程：前n步将数组建立到堆中，后n步按降序提取元素并从右到左建立最终的有序序列。
```java
public static void HeapSort(Integer[] nums){
    for(int i = 1; i < nums.length; i++){
        int j = i;
        while(j > 0){
            if(nums[j] < nums[(j-1)/2])
                break;
            int temp = nums[j];
            nums[j] = nums[(j-1)/2];
            nums[(j-1)/2] = temp;
            j = (j-1)/2;
        }
    }
    for(int i = nums.length-1; i >= 1; i--){
        int temp = nums[0];
        nums[0] = nums[i];
        nums[i] = temp;
        int j = 0;
        while(j < i){
            int c = j*2+1;
            if(c >= i)
                break;
            if(c+1 < i && nums[c+1] >= nums[c])
                c += 1;
            if(nums[j] >= nums[c])
                break;
            int t = nums[c];
            nums[c] = nums[j];
            nums[j] = t;
            j = c;
        }
    }
}
```
算法分析：
- 堆排序也是一种不稳定的排序算法。
- 堆排序的最坏时间复杂度为O(nlogn)。
- 堆序的平均性能较接近于最坏性能。由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。

堆排序的两个关键函数
- Siftup,向上筛选，heap(1,n-1)->heap(1,n)
```python
void siftup(n)
    pre n > 0 && heap(1,n-1)
    post heap(1,n) 

    i = n
    loop:
        if i == 1
            break;
        p = i/2
        if(x[p] <= x[i])
            break
        swap(x[p],x[i])
        i = p
```
- Siftdown,向下筛选，heap(2,n)->heap(1,n)
```python
void siftdown(n)
    pre heap(2,n) && n >= 0
    post heap(1,n)

    i = 1
    loop:
        c = 2*i
        if c > n
            break
        if c+1 <= n && x[c+1] < x[c]
            c++
        if x[i] <= x[c]
            break
        swap(x[c],x[i])
        i = c
```

### 冒泡排序
基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。
```java
public static void BubbleSort(Integer[] nums){
    for(int i = 0; i < nums.length-1; i++){
        for(int j = nums.length-1; j > i; j--){
            if(nums[j] < nums[j-1]){
                int temp = nums[j];
                nums[j] = nums[j-1];
                nums[j-1] = temp;
            }
        }
    }
}
```
算法分析：冒泡排序是一种稳定的排序。
- 若文件初状为正序，则一趟起泡就可完成排序，排序码的比较次数为n-1，且没有记录移动，时间复杂度是O(n)
- 若文件初态为逆序，则需要n-1趟起泡，每趟进行n-i次排序码的比较，且每次比较都移动三次，比较和移动次数均达到最大值∶O(n2)
- 冒泡排序平均时间复杂度为O(n2)

### 快速排序
基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。
```java
public static void QuickSort(Integer[] nums, int left, int right){
    if(left >= right)
        return;
    int m = left;
    int t = nums[left];
    for(int i = left+1; i <= right; i++){
        if(nums[i] < t){
            int temp = nums[++m];
            nums[m] = nums[i];
            nums[i] = temp;
        }
    }
    nums[left] = nums[m];
    nums[m] = t;
    QuickSort(nums, left, m-1);
    QuickSort(nums,m+1, right);
}
```
考虑一种极端的情况：n个相同元素组成的数组。对于这种输入，插入排序的性能非常好：每个元素需要移动的距离都为0，所以总运行时间为O(n)。但QuickSort函数的性能却非常差。n-1次划分中每次都需要O(n)时间来去掉一个元素，所以总运行时间为O(n^2)。于是，考虑使用双向划分可以避免这个问题：
使用下标i和j表示初始化时待划分数组的两端索引。主循环中有两个内循环，第一个内循环将i向右移过小元素，遇到大元素停止；第二个内循环将j向左移过大元素，遇到小元素停止。然后主循环测试这两个下标是否交叉并交换它们的值。
```java
public static void BetterQuickSort(Integer[] nums, int left, int right){
    if(left >= right)
        return;
    int i = left, j = right+1;
    int t = nums[left];
    while(true){
        while(++i <= right && nums[i] < t);
        while(nums[--j] > t);
        if(i > j)
            break;
        swap(nums[i],nums[j]);
    }
    swap(nums[left],nums[j]);
    BetterQuickSort(nums, left, j-1);
    BetterQuickSort(nums, j+1, right);
}
```
算法分析：
- 快速排序是不稳定的排序。
- 快速排序的时间复杂度为O(nlogn)。
- 当n较大时使用快排比较好，当序列基本有序时用快排反而不好。

### 归并排序
基本思想:归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。
```java
public static void MergeSort(Integer[] nums,int left, int right){
    if(left >= right)
        return;
    int mid = (left+right)/2;
    MergeSort(nums, left, mid);
    MergeSort(nums,mid+1, right);
    Merge(nums, left, mid, right);
}

public static void Merge(Integer[] nums, int left, int mid, int right){
    Integer[] temp = new  Integer[nums.length];
    int i = left, j = mid+1, k = left;
    while(i <= mid && j <= right){
        if(nums[i] < nums[j])
            temp[k++] = nums[i++];
        else
            temp[k++] = nums[j++];
    }
    while(i <= mid){
        temp[k++] = nums[i++];
    }
    while(j <= right){
        temp[k++] = nums[j++];
    }
    for(i = left; i <= right; i++)
        nums[i] = temp[i];
}
```
算法分析：
- 归并排序是稳定的排序方法。
- 归并排序的时间复杂度为O(nlogn)。
- 速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。

排序算法 | 平均时间 | 最好时间 | 最坏时间 | 空间复杂度 | 稳定性
---|---|---|---|---|---
直接插入|O(n^2)|O(n)|O(n^2)|O(1)|稳定
二分插入|O(n^2)|O(n)|O(n^2)|O(1)|稳定
希尔排序|O(nlogn)|O(n)|O(n^2)|O(1)|不稳定
直接选择|O(n^2)|O(n^2)|O(n^2)|O(1)|不稳定
堆排序|O(nlogn)|O(nlogn)|O(nlogn)|O(1)|不稳定
冒泡排序|O(n^2)|O(n)|O(n^2)|O(1)|稳定
快速排序|O(nlogn)|O(nlogn)|O(n^2)|O(nlogn)|不稳定
归并排序|O(nlogn)|O(nlogn)|O(nlogn)|O(1)|稳定

- 当排序记录个数n较大，关键码分布较随机，且对稳定性不作要求时，采用快速排序为宜。 
- 当待排序记录个数n较大，内存空间允许，且要求稳定排序时，采用归并排序。 
- 当待排序记录个数n较大，关键码分布可能出现正序或逆序的情况，且对稳定性不作要求时，采用堆排序或归并排序。 
- 当待排序记录个数n较大，而只要找出最小的前几个记录，采用堆排序或简单选择排序。 
- 当待排序记录个数n较小（如小于100）时，记录已基本有序，且要求稳定时，采用直接插入排序。 
- 当待排序记录个数n较小，记录所含数据项较多，所占存储空间较大时，采用简单选择排序。