<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TheCoy&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/4f0d97202f9939732dbd47d7b311390f</icon>
  <subtitle>做一个傻子多么好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thecoy.github.io/"/>
  <updated>2020-01-05T15:05:05.629Z</updated>
  <id>http://thecoy.github.io/</id>
  
  <author>
    <name>TheCoy</name>
    <email>coy20150428@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的9102</title>
    <link href="http://thecoy.github.io/2020/01/05/%E6%88%91%E7%9A%849102/"/>
    <id>http://thecoy.github.io/2020/01/05/我的9102/</id>
    <published>2020-01-05T14:22:58.000Z</published>
    <updated>2020-01-05T15:05:05.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="9102年完结啦"><a href="#9102年完结啦" class="headerlink" title="9102年完结啦"></a>9102年完结啦</h2><ul><li>不知不觉2019就这么悄无声息地过去了，来不及在最后一天做任何的总结，大概是忙碌让身影疲惫，也可能对未来没有任何更新的展望。但人终归是要向前看的，哪怕过去一无是处，也不妨碍我继续向前</li></ul><a id="more"></a><h3 id="过去一年的改变"><a href="#过去一年的改变" class="headerlink" title="过去一年的改变"></a>过去一年的改变</h3><ul><li><p>变胖了：差不多涨了近20斤，虽然总是内心深处地提醒自己，不要变大腹便便的中年油腻大叔，但运动的缺乏导致新城代谢的速度追不上体重的增长</p></li><li><p>成长变慢了：不及毕业那段时间的学习热情，自我驱动的学习变得少了，可能工作的驾轻就熟让我有些自我感觉良好，突然觉得是时候突破自己舒适区了，无论以何种形式。 “只有变才是不变的”这句话真是总结的妙啊</p></li></ul><h3 id="一点自我感悟"><a href="#一点自我感悟" class="headerlink" title="一点自我感悟"></a>一点自我感悟</h3><blockquote><p>十一国庆回家的路上莫名地悟出来属于我自己的“四个永远”，仅以提醒与激励我自己。</p></blockquote><ol><li>永远保持美好生活的渴望</li><li>永远警惕自视甚微的心理</li><li>永远相信滴水穿石的力量</li><li>永远追求自信乐观的状态</li></ol><h3 id="一点胡言乱语"><a href="#一点胡言乱语" class="headerlink" title="一点胡言乱语"></a>一点胡言乱语</h3><ul><li>过去的一年内心很乱，感觉自己想要去做的事情很多，但仿佛又什么都没做。想积极去拓展一门爱好，想持续去精进一些技术，想勇敢尝试一些改变，总之时间在还没反应过来之前就光速流逝过去了，只留下一脸懵逼的我。。。</li></ul><h3 id="立一些Flag"><a href="#立一些Flag" class="headerlink" title="立一些Flag"></a>立一些Flag</h3><ol><li>把健身坚持下来</li><li>完成技术上的自我转型与突破</li><li>结交更多的朋友，包括妹子</li><li>培养一门业余爱好，尽可能的专业</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;9102年完结啦&quot;&gt;&lt;a href=&quot;#9102年完结啦&quot; class=&quot;headerlink&quot; title=&quot;9102年完结啦&quot;&gt;&lt;/a&gt;9102年完结啦&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;不知不觉2019就这么悄无声息地过去了，来不及在最后一天做任何的总结，大概是忙碌让身影疲惫，也可能对未来没有任何更新的展望。但人终归是要向前看的，哪怕过去一无是处，也不妨碍我继续向前&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://thecoy.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>一个bug的来龙去脉</title>
    <link href="http://thecoy.github.io/2019/06/21/%E4%B8%80%E4%B8%AAbug%E7%9A%84%E6%9D%A5%E9%BE%99%E5%8E%BB%E8%84%89/"/>
    <id>http://thecoy.github.io/2019/06/21/一个bug的来龙去脉/</id>
    <published>2019-06-21T06:07:28.000Z</published>
    <updated>2020-07-21T06:33:09.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个报警的连锁反应"><a href="#一个报警的连锁反应" class="headerlink" title="一个报警的连锁反应"></a>一个报警的连锁反应</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>2019年06月20日，又是一个风(bai)和(wu)日(liao)丽(lai)的日子，早上刚到公司，刷会手机喝喝水准备开站会的前夕，突然收到一封报警邮件。尽管早已习惯报警邮件的晚高峰轰炸，但头一次在美好的早晨被报警邮件所叨扰，还是不免心头一紧。</p></blockquote><h2 id="似曾相识"><a href="#似曾相识" class="headerlink" title="似曾相识"></a>似曾相识</h2><p>然后开完站会，就发现这个报警和上次的似乎差不多。具体报警内容是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP Fatal error:  Allowed memory size of 67108864 bytes exhausted (tried to allocate 20480 bytes)</span><br></pre></td></tr></table></figure><p>之前也出现过一次相同的内存爆掉的问题，而且是同样的文件，同样的位置。当时定位到的问题根源是这样的：</p><ol><li>QA自动化在对线上的接口作测试，其中就包括了这一个接口，但是它的测试用例集中在了某一个具体的caseID，导致这个caseID下的数据量产生异常</li><li>以往业务并没有考虑数据量异常的情形，因此在对DB库做query的时候并没有做limit限制，进而导致后续的列表Query在操作处理时直接内存爆掉了</li><li>此时自动化脚本还在不停地”刷”这个接口，而且最要命的是，与此同时还有一个第三方服务在异步消费过程中也会query相关的caseID数据列表，而由于内存爆掉，进程异常退出，所以消费方认为不成功，于是不停地疯狂重试，结果就导致了错误日志不停地在刷</li></ol><p>所以，从问题的产生的表象看：<br>QA自动化测试的骚操作 -&gt; 数据库数据量异常 -&gt; 数据列表Query异常 -&gt; 第三方消费异常 -&gt; 报警</p><p>从问题的产生根源看：<br>产品细节que的不完整 -&gt; 代码逻辑设计不够健壮 -&gt; 随异常数据产生开始曝露代码BUG -&gt; 报警</p><h2 id="反反复复"><a href="#反反复复" class="headerlink" title="反反复复"></a>反反复复</h2><p>继第一次的报警之后，当时分析的是这种情况属于个例问题，于是就针对特定的caseID做了屏蔽处理。当时考虑的是正常的业务场景是不会出现这种数据量异常的大量情形，而且针对该类问题的查询确实有一次query整个列表的使用场景在，于是当时就是这么处理过去了。</p><p>然后，这一次一开始报警的时候我又以为是一些自动化测试开始搞事情了，于是我想要杜绝这类问题再次发生，只能去做保证和限制了。因为永远不要相信第三方是一名后端工程师必备的常识。于是先代码加上Limit限制再去追责吧。</p><p>然而问题的处理并没有想象中那么顺利：</p><ol><li>代码改动比较慌乱，导致引入了一些其它异常出现</li><li>代码改动时发现了代码规范的问题，其实如果代码写的好一些，应该也不会出现问题1</li><li>临时的方案尚有缺陷，并没有兼顾到所有场景，需要后面持续改进优化</li></ol><p>总之，伴随着上述的问题跌跌撞撞中算是解决了线上的报警问题。OK，接下来开始分析和追查问题产生的原因：</p><ol><li>分析日志找到了caseID，但发现竟然和上次的凶手不是同一个，并且和上任凶手确认过确实不是他们的锅。嗯，我承认之前冤枉了他们</li><li>翻查相关case的数据记录，发现请求虽然频率较低（约1次/秒），但仍然可认为是有恶意的，尽管不知道是出于什么目的。</li><li>分析相关联用户的利益相关数据，发现了用户的财富记录不太正常，狐狸尾巴终于还是露出来了。</li><li>既然是为了刷财富，那必然是有BUG，那么就审查相关代码吧。果不其然，经过代码查阅发现是之前的一个签到任务引起的BUG，用户可以通过重复请求这个接口从而达到刷财富值的目的。</li></ol><h2 id="细思恐极"><a href="#细思恐极" class="headerlink" title="细思恐极"></a>细思恐极</h2><p>好了，问题的原因也定位清楚了，知道问题的根源，解决起来自然也就是水到渠成的事情啦。</p><p>不过在解决BUG的过程中，由于相关代码的编写是由另外一位同事完成的，代码风格与规范也是各有一番千秋，简单地说就是，你要先看懂他写的代码并明白他的代码逻辑设计意图，才敢放手去改。不然保不齐又会引入其它新的问题。心有猛虎，细嗅蔷薇，小心驶得万年船啊！</p><p>问题从产生到发现到解决，其实过程并不是很长，但直到我最后一次上完线，修改完这个bug之后，再仔细回过头想一想这个事情，发现还是有很多值得思考与反思的地方：</p><ol><li>插入式需求的完成度强依赖于对于业务的熟悉程度，贸然去改一个之前不是很熟悉的业务，其实是很危险的一件事</li><li>代码的规范程度之于BUG的修改、他人的阅读、扩展性编写的重要性，殊不知风格迥异的代码简直是对后续维护者的折磨</li><li>产品需求的细节沟通程度决定了这个需求的完善程度，有的时候沟通的缺乏轻则导致需求设计的完善度，重则产生致命的漏洞bug。</li></ol><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>问题其实不算什么，但是透过这次问题确实让我感受比较五味杂陈，你说不出是哪里不爽，但觉得这个世界其实没有那么善良。总而言之，当好一名代码工程师确实不是一件容易的事情！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一个报警的连锁反应&quot;&gt;&lt;a href=&quot;#一个报警的连锁反应&quot; class=&quot;headerlink&quot; title=&quot;一个报警的连锁反应&quot;&gt;&lt;/a&gt;一个报警的连锁反应&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://thecoy.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>冲鸭2019</title>
    <link href="http://thecoy.github.io/2019/02/26/%E5%86%B2%E9%B8%AD2019/"/>
    <id>http://thecoy.github.io/2019/02/26/冲鸭2019/</id>
    <published>2019-02-26T14:02:25.000Z</published>
    <updated>2019-02-26T14:43:19.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加油2019年"><a href="#加油2019年" class="headerlink" title="加油2019年"></a>加油2019年</h1><ul><li>不知不觉毕业已经大半年了，本来早就想写点什么的，或总结、或展望，无奈自己确实懒入骨髓已久，也可能停笔多时，想写什么一时也写不出来，但只要想起来去写就总归是好的</li><li>今天看到耗子叔更新了博客谈了一些自己的价值观和想法，谈到他24岁从银行毅然辞职走上程序员的道路，让我忽地想起来那句“实迷途其未远，觉今是而昨非”，嗯……，我想一切其实都还来得及，毕竟选择是自己的，明天仍然还是掌握在自己手中</li></ul><a id="more"></a><h2 id="过去的半年"><a href="#过去的半年" class="headerlink" title="过去的半年"></a>过去的半年</h2><ul><li>毕业工作刚过去的半年，个人的成长既不能妄自菲薄地说啥也没有，但也确实还有很多能做得更好的地方：技术的自我驱动、对待工作和生活的积极性，以及一堆疯狂吃灰的书</li></ul><h2 id="对自己的一点期许"><a href="#对自己的一点期许" class="headerlink" title="对自己的一点期许"></a>对自己的一点期许</h2><ul><li><p>多一些想法</p><blockquote><p>这一点确实有点想捶自己胸口的冲动，可能自己书读的太少的缘故吧，“吾尝终日而思矣，不如须臾之所学”还是有些道理的罢，所以立下一个小目标：今年要读完10本书，不限类型、不限媒介</p></blockquote></li><li><p>多造点玩具和折腾折腾</p><blockquote><p>尽管这听起来更像是一个学生的自我要求，但真的在工作中能让你随意自由发挥的空间还是有限的，要时刻不停地折腾东西，保持作为一个技术人应该有的自我驱动</p></blockquote></li><li><p>多写点啥</p><blockquote><p>写写日记什么的也是好的，哪怕写日记听着像是一件很幼稚的事情，但确实是比较有效地能让自己审视自我内心的方式。无论是写什么内容，观影感受、技术总结、经验积累，或是天马行空也好，“我思，故我在”，哈哈哈，我也是个哲学家了</p></blockquote></li></ul><h2 id="留白"><a href="#留白" class="headerlink" title="留白"></a>留白</h2><ul><li>未来很远，世界很美，我也想证实自己存活过</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;加油2019年&quot;&gt;&lt;a href=&quot;#加油2019年&quot; class=&quot;headerlink&quot; title=&quot;加油2019年&quot;&gt;&lt;/a&gt;加油2019年&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;不知不觉毕业已经大半年了，本来早就想写点什么的，或总结、或展望，无奈自己确实懒入骨髓已久，也可能停笔多时，想写什么一时也写不出来，但只要想起来去写就总归是好的&lt;/li&gt;
&lt;li&gt;今天看到耗子叔更新了博客谈了一些自己的价值观和想法，谈到他24岁从银行毅然辞职走上程序员的道路，让我忽地想起来那句“实迷途其未远，觉今是而昨非”，嗯……，我想一切其实都还来得及，毕竟选择是自己的，明天仍然还是掌握在自己手中&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://thecoy.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ES学习笔记</title>
    <link href="http://thecoy.github.io/2018/11/21/ES%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://thecoy.github.io/2018/11/21/ES学习笔记/</id>
    <published>2018-11-21T15:45:26.000Z</published>
    <updated>2018-11-23T15:50:25.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Elasticsearch</strong> 是一个实时的分布式搜索分析引擎, 建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。</p><ul><li>一个分布式的实时文档存储，每个字段可以被索引与搜索</li><li>一个分布式实时分析搜索引擎</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li></ul><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li>全文检索</li><li>结构化搜索</li><li>分析</li></ul><a id="more"></a><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>索引（名词）</li></ul><p>一个 索引 类似于传统关系数据库中的一个 数据库 ，是一个存储关系型文档的地方。 索引 (index) 的复数词为 indices 或 indexes</p><ul><li>索引（动词）</li></ul><p>索引一个文档 就是存储一个文档到一个 索引 （名词）中以便它可以被检索和查询到。这非常类似于 SQL 语句中的 INSERT 关键词，除了文档已存在时新文档会替换旧文档情况之外。</p><ul><li>倒排索引</li></ul><p>关系型数据库通过增加一个 索引 比如一个 B树（B-tree）索引 到指定的列上，以便提升数据检索速度。Elasticsearch 和 Lucene 使用了一个叫做 倒排索引 的结构来达到相同的目的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT "localhost:9200/megacorp/employee/1" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">    "first_name" : "John",</span><br><span class="line">    "last_name" :  "Smith",</span><br><span class="line">    "age" :        25,</span><br><span class="line">    "about" :      "I love to go rock climbing",</span><br><span class="line">    "interests": [ "sports", "music" ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ElasticSearch&quot;&gt;&lt;a href=&quot;#ElasticSearch&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch&quot;&gt;&lt;/a&gt;ElasticSearch&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Elasticsearch&lt;/strong&gt; 是一个实时的分布式搜索分析引擎, 建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个分布式的实时文档存储，每个字段可以被索引与搜索&lt;/li&gt;
&lt;li&gt;一个分布式实时分析搜索引擎&lt;/li&gt;
&lt;li&gt;能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;主要功能&quot;&gt;&lt;a href=&quot;#主要功能&quot; class=&quot;headerlink&quot; title=&quot;主要功能&quot;&gt;&lt;/a&gt;主要功能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;全文检索&lt;/li&gt;
&lt;li&gt;结构化搜索&lt;/li&gt;
&lt;li&gt;分析&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://thecoy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://thecoy.github.io/2017/08/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://thecoy.github.io/2017/08/28/排序算法总结/</id>
    <published>2017-08-28T07:35:45.000Z</published>
    <updated>2018-11-21T15:40:22.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>算法实现过程：筛选过程通过一个从右到左的循环实现，该循环使用变量j跟踪被筛选的元素。只要该元素具有前驱（j&gt;0）且没有达到最终位置，循环就交换该元素和它的前驱，代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(Integer[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; a[j-<span class="number">1</span>]&gt;a[j]; j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[j];</span><br><span class="line">            a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">            a[j-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：</p><ul><li>给定待排序的数列初态不同时，直接插入排序所耗费的时间有很大差异。</li><li>若初态为正序，则每个待插入的记录只需比较一次就能找到对应位置插入，此时算法的时间复杂度为O(n)。</li><li>若初态为反序，则第i个待插入记录需要比较i+1次才能找到合适位置插入，此时时间复杂度为O(n^2)。</li></ul><a id="more"></a><h3 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h3><p>基本思想：二分法插入排序的思想和直接插入一样，只是找合适的插入位置的方式不同，这里通过二分法找到合适的位置，可以减少比较的次数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BinaryInsertSort</span><span class="params">(Integer[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[mid])</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= left; j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[j];</span><br><span class="line">            a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">            a[j-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：</p><ul><li>二分插入排序的比较次数与待排序记录的初始状态无关，仅依赖记录的个数。</li><li>当n较大时，比直接插入排序的最大比较次数少得多，但大于直接插入排序的最小比较次数。</li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>基本思想：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量<code>d2&lt;d1</code>重复上述的分组和排序，直至所取的增量<code>dt=1(dt&lt;dt-l&lt;…&lt;d2&lt;d1)</code>，即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(Integer[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = nums.length;</span><br><span class="line">    <span class="keyword">while</span>(d &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        d = d/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+d;j &lt; nums.length;j = j+d)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &gt; i &amp;&amp; nums[k] &lt; nums[k-d];k = k -d)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[k];</span><br><span class="line">                    nums[k] = nums[k-d];</span><br><span class="line">                    nums[k-d] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>希尔排序的时间性能优于直接插入排序，原因如下：</p><ul><li>当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。</li><li>当n值较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0(n2)差别不大。</li><li>在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。</li></ul><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p>算法思想：每趟从待排序的记录序列中选择关键字最小的记录放置到已排序表的最前位置，直到全部排完。时间复杂度为O(n^2)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(Integer[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序算法是一个两阶段的过程：前n步将数组建立到堆中，后n步按降序提取元素并从右到左建立最终的有序序列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(Integer[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[(j-<span class="number">1</span>)/<span class="number">2</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">            nums[j] = nums[(j-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">            nums[(j-<span class="number">1</span>)/<span class="number">2</span>] = temp;</span><br><span class="line">            j = (j-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; i)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = j*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(c+<span class="number">1</span> &lt; i &amp;&amp; nums[c+<span class="number">1</span>] &gt;= nums[c])</span><br><span class="line">                c += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt;= nums[c])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> t = nums[c];</span><br><span class="line">            nums[c] = nums[j];</span><br><span class="line">            nums[j] = t;</span><br><span class="line">            j = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：</p><ul><li>堆排序也是一种不稳定的排序算法。</li><li>堆排序的最坏时间复杂度为O(nlogn)。</li><li>堆序的平均性能较接近于最坏性能。由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。</li></ul><p>堆排序的两个关键函数</p><ul><li><p>Siftup,向上筛选，heap(1,n-1)-&gt;heap(1,n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void siftup(n)</span><br><span class="line">    pre n &gt; <span class="number">0</span> &amp;&amp; heap(<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">    post heap(<span class="number">1</span>,n) </span><br><span class="line"></span><br><span class="line">    i = n</span><br><span class="line">    loop:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p = i/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span>(x[p] &lt;= x[i])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        swap(x[p],x[i])</span><br><span class="line">        i = p</span><br></pre></td></tr></table></figure></li><li><p>Siftdown,向下筛选，heap(2,n)-&gt;heap(1,n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void siftdown(n)</span><br><span class="line">    pre heap(<span class="number">2</span>,n) &amp;&amp; n &gt;= <span class="number">0</span></span><br><span class="line">    post heap(<span class="number">1</span>,n)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    loop:</span><br><span class="line">        c = <span class="number">2</span>*i</span><br><span class="line">        <span class="keyword">if</span> c &gt; n</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> c+<span class="number">1</span> &lt;= n &amp;&amp; x[c+<span class="number">1</span>] &lt; x[c]</span><br><span class="line">            c++</span><br><span class="line">        <span class="keyword">if</span> x[i] &lt;= x[c]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        swap(x[c],x[i])</span><br><span class="line">        i = c</span><br></pre></td></tr></table></figure></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(Integer[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.length-<span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">                nums[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：冒泡排序是一种稳定的排序。</p><ul><li>若文件初状为正序，则一趟起泡就可完成排序，排序码的比较次数为n-1，且没有记录移动，时间复杂度是O(n)</li><li>若文件初态为逆序，则需要n-1趟起泡，每趟进行n-i次排序码的比较，且每次比较都移动三次，比较和移动次数均达到最大值∶O(n2)</li><li>冒泡排序平均时间复杂度为O(n2)</li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(Integer[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = left;</span><br><span class="line">    <span class="keyword">int</span> t = nums[left];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left+<span class="number">1</span>; i &lt;= right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; t)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[++m];</span><br><span class="line">            nums[m] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = nums[m];</span><br><span class="line">    nums[m] = t;</span><br><span class="line">    QuickSort(nums, left, m-<span class="number">1</span>);</span><br><span class="line">    QuickSort(nums,m+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>考虑一种极端的情况：n个相同元素组成的数组。对于这种输入，插入排序的性能非常好：每个元素需要移动的距离都为0，所以总运行时间为O(n)。但QuickSort函数的性能却非常差。n-1次划分中每次都需要O(n)时间来去掉一个元素，所以总运行时间为O(n^2)。于是，考虑使用双向划分可以避免这个问题：<br>使用下标i和j表示初始化时待划分数组的两端索引。主循环中有两个内循环，第一个内循环将i向右移过小元素，遇到大元素停止；第二个内循环将j向左移过大元素，遇到小元素停止。然后主循环测试这两个下标是否交叉并交换它们的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BetterQuickSort</span><span class="params">(Integer[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = nums[left];</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(++i &lt;= right &amp;&amp; nums[i] &lt; t);</span><br><span class="line">        <span class="keyword">while</span>(nums[--j] &gt; t);</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(nums[i],nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[left],nums[j]);</span><br><span class="line">    BetterQuickSort(nums, left, j-<span class="number">1</span>);</span><br><span class="line">    BetterQuickSort(nums, j+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：</p><ul><li>快速排序是不稳定的排序。</li><li>快速排序的时间复杂度为O(nlogn)。</li><li>当n较大时使用快排比较好，当序列基本有序时用快排反而不好。</li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>基本思想:归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(Integer[] nums,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">    MergeSort(nums, left, mid);</span><br><span class="line">    MergeSort(nums,mid+<span class="number">1</span>, right);</span><br><span class="line">    Merge(nums, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(Integer[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    Integer[] temp = <span class="keyword">new</span>  Integer[nums.length];</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid+<span class="number">1</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[j])</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right)&#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = left; i &lt;= right; i++)</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：</p><ul><li>归并排序是稳定的排序方法。</li><li>归并排序的时间复杂度为O(nlogn)。</li><li>速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>排序算法</th><th>平均时间</th><th>最好时间</th><th>最坏时间</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>二分插入</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>直接选择</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(nlogn)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>稳定</td></tr></tbody></table><ul><li>当排序记录个数n较大，关键码分布较随机，且对稳定性不作要求时，采用快速排序为宜。 </li><li>当待排序记录个数n较大，内存空间允许，且要求稳定排序时，采用归并排序。 </li><li>当待排序记录个数n较大，关键码分布可能出现正序或逆序的情况，且对稳定性不作要求时，采用堆排序或归并排序。 </li><li>当待排序记录个数n较大，而只要找出最小的前几个记录，采用堆排序或简单选择排序。 </li><li>当待排序记录个数n较小（如小于100）时，记录已基本有序，且要求稳定时，采用直接插入排序。 </li><li>当待排序记录个数n较小，记录所含数据项较多，所占存储空间较大时，采用简单选择排序。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;直接插入排序&quot;&gt;&lt;a href=&quot;#直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序&quot;&gt;&lt;/a&gt;直接插入排序&lt;/h3&gt;&lt;p&gt;算法实现过程：筛选过程通过一个从右到左的循环实现，该循环使用变量j跟踪被筛选的元素。只要该元素具有前驱（j&amp;gt;0）且没有达到最终位置，循环就交换该元素和它的前驱，代码实现如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InsertSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Integer[] a)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; a.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = i; j &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; a[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&amp;gt;a[j]; j--)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            a[j] = a[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            a[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;算法分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定待排序的数列初态不同时，直接插入排序所耗费的时间有很大差异。&lt;/li&gt;
&lt;li&gt;若初态为正序，则每个待插入的记录只需比较一次就能找到对应位置插入，此时算法的时间复杂度为O(n)。&lt;/li&gt;
&lt;li&gt;若初态为反序，则第i个待插入记录需要比较i+1次才能找到合适位置插入，此时时间复杂度为O(n^2)。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://thecoy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JS异步设计</title>
    <link href="http://thecoy.github.io/2017/08/27/JS%E5%BC%82%E6%AD%A5%E8%AE%BE%E8%AE%A1/"/>
    <id>http://thecoy.github.io/2017/08/27/JS异步设计/</id>
    <published>2017-08-27T03:55:16.000Z</published>
    <updated>2018-11-21T15:40:22.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-异步任务设计"><a href="#JavaScript-异步任务设计" class="headerlink" title="JavaScript 异步任务设计"></a>JavaScript 异步任务设计</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asyncFunA()</span></span><br><span class="line"><span class="comment">// asyncFunB()</span></span><br><span class="line"><span class="comment">// asyncFunC()</span></span><br><span class="line">RunTasks(&#123;</span><br><span class="line">    duration:<span class="number">1000</span>,</span><br><span class="line">    tasks:[</span><br><span class="line">        [asyncFunA, <span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">        asyncFunB,</span><br><span class="line">        [asyncFunC,<span class="string">'baz'</span>]</span><br><span class="line">    ],</span><br><span class="line">    done:<span class="function"><span class="keyword">function</span> (<span class="params">resultA, resultB, resultC</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(resultA, resultB, resultC);</span><br><span class="line">    &#125;,</span><br><span class="line">    fail:<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;,</span><br><span class="line">    timeout:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>要求设计一个RunTask函数，使得三个异步任务在给定时间内执行完后输出对应结果，如果超时则打印超时提示，如果失败则提示任务异常信息：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncFunA = <span class="function"><span class="keyword">function</span> (<span class="params">param1, param2, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'asyncFunctionA running'</span>);</span><br><span class="line">    callback &amp;&amp; callback();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> asyncFunB = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'asyncFunctionB running'</span>);</span><br><span class="line">    callback &amp;&amp; callback();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> asyncFunC = <span class="function"><span class="keyword">function</span> (<span class="params">param1,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> otime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'asyncFunctionC running'</span>);</span><br><span class="line">    <span class="keyword">var</span> ntime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">while</span>(ntime-otime &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">        ntime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"time:"</span> + <span class="built_in">Date</span>(ntime-otime));</span><br><span class="line">    &#125;</span><br><span class="line">    callback &amp;&amp; callback();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">RunTasks</span>(<span class="params">runTasks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> length  =runTasks.tasks.length;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> timer1 = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        timeout = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'-----start-----'</span>);</span><br><span class="line">        <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            timeout = <span class="literal">true</span>;</span><br><span class="line">            callback &amp;&amp; callback();</span><br><span class="line">        &#125;,runTasks.durartion);</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timer = timer1(runTasks.timeout);</span><br><span class="line"></span><br><span class="line">    runTasks.tasks.forEach( <span class="function"><span class="keyword">function</span> (<span class="params">funitem, index </span>)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> fun = funitem;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(funitem)) &#123;</span><br><span class="line">                fun = funitem[<span class="number">0</span>];</span><br><span class="line">                funitem = funitem.slice(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//fun = funitem.splice(0,1);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                funitem = [];</span><br><span class="line">            &#125;</span><br><span class="line">            funitem.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                res[index] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;length;i++ ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!res[i])</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">                timeout || runTasks.done(res);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                fun.apply(<span class="keyword">this</span>, funitem);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">            runTasks.fail(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript-异步任务设计&quot;&gt;&lt;a href=&quot;#JavaScript-异步任务设计&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 异步任务设计&quot;&gt;&lt;/a&gt;JavaScript 异步任务设计&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// asyncFunA()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// asyncFunB()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// asyncFunC()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RunTasks(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    duration:&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tasks:[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [asyncFunA, &lt;span class=&quot;string&quot;&gt;&#39;foo&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        asyncFunB,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [asyncFunC,&lt;span class=&quot;string&quot;&gt;&#39;baz&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    done:&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;resultA, resultB, resultC&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(resultA, resultB, resultC);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fail:&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.error(err);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    timeout:&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;timeout&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="异步" scheme="http://thecoy.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Choose Life</title>
    <link href="http://thecoy.github.io/2017/06/27/Choose-Life/"/>
    <id>http://thecoy.github.io/2017/06/27/Choose-Life/</id>
    <published>2017-06-27T13:43:37.000Z</published>
    <updated>2018-11-21T15:40:22.745Z</updated>
    
    <content type="html"><![CDATA[<p>Choose your future, Veronika. Choose life.</p><p>看完《猜火车2》之后，又倒回去看了几遍Mark对Veronika解释什么是“Choose Life”，电影剧情于我并没有什么特别大的感触，尽管对剧中部分台词的过分沉迷让我甚至对于导演想要表达的东西在正确理解的道路上越走越远，可我还是忍不住想要写下点抑或记录点什么自己的感想…<br><a id="more"></a><br>人们总是喜欢说，人生充满了选择。诚然，人生就是由无数个选择所构成的。</p><p>选择埋头苦读，于是还要选择挤过高考的独木桥</p><p>选择默不作声，于是还要选择独自扛下所有不平等公正的遭遇</p><p>选择独自前行，于是还要选择拥有并享受孤独</p><p><img src="/assets/blogImg/p1706271.jpg" alt="image"></p><p>20年前，雷顿在开场中愤世嫉俗地说道，“选择生活，选择工作，选择事业，选择家庭，选他妈的大电视，选洗衣机、车子、CD、电动开罐器，选择健康、低胆固醇和牙医保险、定息低率贷款，选择房子，选择朋友，选择休闲服跟搭配的行李箱，选择各种布料的西装，选DIY，怀疑自己是什么？看心智麻痹的电视，嘴里塞满垃圾食物，最后整个人腐烂到底，在悲惨的家里生一堆自私的混蛋小孩烦死自己，不过是难堪罢了，选择未来，选择生活，…我干嘛做这些事？”</p><p><img src="/assets/blogImg/p1706272.jpg" alt="image"></p><p>20年后，雷顿在海报里这样写道，“选择生活，选择facebook、twitter、Instagram并且希望有人在乎。选择看着你的旧情人，希望你能改变当时做错的事情。选择看着历史自我重复。选择你的未来，选择电视真人秀，荡妇羞辱，色情报复。选择零工时的合约，和一段两小时的上班路程。并且帮你的小孩做一模一样的选择，一个只会更糟，就像是你在某人厨房打了一剂不知名毒品后感到窒息般痛苦的选择，然后深呼吸。”<br>你始终是个瘾君子，那么就去上瘾吧！去找些别的什么，让你真正上瘾的事情。</p><blockquote><p>Choose unfulfilled promise and wishing you’d done it all differently.<br>选择不履行承诺，之后又希望自己从头来过</p></blockquote><blockquote><p>Choose never learning from your own mistakes. Choose watching history repeat itself.<br>选择从不吸取自己错误的教训 选择看着历史一遍遍重演</p></blockquote><blockquote><p>Choose the slow reconciliation towards what you can get, rather than what you always hoped for. Settle for less and keep a brave face on it.<br>选择慢慢屈就于你能得到的，而不是你一直都想要的。见好就收 但面子上还要硬撑</p></blockquote><blockquote><p>Choose disappointment and choose losing the ones you love, then as they fall from view, a piece of you dies with them until you can see that one day in the future, piece by piece, they will all be gone and there’ll be nothing left of you to call alive or dead.<br>选择失望 选择痛失所爱，随她们渐行渐远，你的一部分也与她们一并消逝 你知道将来的某一天，一点又一点，它们都消逝无踪 那时你的自我一点不剩 生死难明</p></blockquote><blockquote><p>Choose your future, Veronika. Choose life.<br>选择你的未来，Veronika，选择人生</p></blockquote><p>无论是选择，还是被选择，决定权其实最终还是在自己的手里！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Choose your future, Veronika. Choose life.&lt;/p&gt;
&lt;p&gt;看完《猜火车2》之后，又倒回去看了几遍Mark对Veronika解释什么是“Choose Life”，电影剧情于我并没有什么特别大的感触，尽管对剧中部分台词的过分沉迷让我甚至对于导演想要表达的东西在正确理解的道路上越走越远，可我还是忍不住想要写下点抑或记录点什么自己的感想…&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://thecoy.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Lambda之初体验</title>
    <link href="http://thecoy.github.io/2017/06/25/Lambda%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://thecoy.github.io/2017/06/25/Lambda之初体验/</id>
    <published>2017-06-25T09:26:19.000Z</published>
    <updated>2018-11-21T15:40:22.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式之初体验"><a href="#Lambda表达式之初体验" class="headerlink" title="Lambda表达式之初体验"></a>Lambda表达式之初体验</h2><p>最近在重新系统地学习Python这门语言，在学习关于数据结构中的列表构造部分时，里面也有提到Lambda表达式，不过只是浅尝辄止罢了，加上之前Java（8以上的版本才支持）里面也有用到过Lambda这个东西，索性单独学习并记录之。<br><a id="more"></a></p><h3 id="Lambda表达式的定义"><a href="#Lambda表达式的定义" class="headerlink" title="Lambda表达式的定义"></a>Lambda表达式的定义</h3><p>Lambda 表达式是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。</p><h3 id="Lambda表达的不完全列举用法"><a href="#Lambda表达的不完全列举用法" class="headerlink" title="Lambda表达的不完全列举用法"></a>Lambda表达的不完全列举用法</h3><p>1.使用Lambda表达式作为函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x:x**<span class="number">2</span></span><br><span class="line">x = f(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><ul><li>一个返回某个集合的所有子集的 lambda 函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x:[[y <span class="keyword">for</span> j, y <span class="keyword">in</span> enumerate(set(x)) <span class="keyword">if</span>(i &gt;&gt; j) &amp; <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>**len(set(x)))]</span><br></pre></td></tr></table></figure></li></ul><p>2.使用Lambda表达式作为参数传递：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pairs = [(<span class="number">1</span>, <span class="string">'one'</span>), (<span class="number">2</span>, <span class="string">'two'</span>), (<span class="number">3</span>, <span class="string">'three'</span>), (<span class="number">4</span>, <span class="string">'four'</span>)]</span><br><span class="line">pairs.sort(key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p>3.使用Lambda表达式构造列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = list(map(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,range(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure></p><ul><li>map() 函数，它可以将一个函数映射到一个可枚举类型上面。于是map(f,a)就意味着将函数f依次作用在a的每一个元素上。</li></ul><p>4.使用Lambda函数作为闭包：</p><blockquote><p>闭包就是一个定义在函数内部的函数，闭包使得变量即使脱离了该函数的作用域范围也依然能被访问到。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x+n</span><br><span class="line">f = foo(<span class="number">0</span>)</span><br><span class="line">print(f(<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="下面是对比在Python中使用嵌套结构和Lambda两种方式构造列表的比较："><a href="#下面是对比在Python中使用嵌套结构和Lambda两种方式构造列表的比较：" class="headerlink" title="下面是对比在Python中使用嵌套结构和Lambda两种方式构造列表的比较："></a>下面是对比在Python中使用嵌套结构和Lambda两种方式构造列表的比较：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">            [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">                [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#嵌套结构的列表推导式</span></span><br><span class="line">res = [[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]))]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Lambda表达式构造外层列表，列表推导式构造里层列表</span></span><br><span class="line">res = list(map(<span class="keyword">lambda</span> x:[row[x] <span class="keyword">for</span> row <span class="keyword">in</span> matrix],range(len(matrix[<span class="number">0</span>]))))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Lambda表达式构造里层列表，列表推导式构造外层列表-1</span></span><br><span class="line">res = [list(map(<span class="keyword">lambda</span> row:row[x],matrix)) <span class="keyword">for</span> x <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]))]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Lambda表达式构造里层列表，列表推导式构造外层列表-2</span></span><br><span class="line">res = [list(map(<span class="keyword">lambda</span> row:row[x],[row <span class="keyword">for</span> row <span class="keyword">in</span> matrix])) <span class="keyword">for</span> x <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#双Lambda方式构造列表-1</span></span><br><span class="line">res = list(map(<span class="keyword">lambda</span> x:list(map(<span class="keyword">lambda</span> row:row[x],matrix)),range(len(matrix[<span class="number">0</span>]))))</span><br><span class="line"></span><br><span class="line"><span class="comment">#双Lambda方式构造列表-2</span></span><br><span class="line">res = list(map(<span class="keyword">lambda</span> x:list(map(<span class="keyword">lambda</span> row:row[x],[row <span class="keyword">for</span> row <span class="keyword">in</span> matrix])),range(len(matrix[<span class="number">0</span>]))))</span><br></pre></td></tr></table></figure><p><strong>未完待续ing….</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Lambda表达式之初体验&quot;&gt;&lt;a href=&quot;#Lambda表达式之初体验&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式之初体验&quot;&gt;&lt;/a&gt;Lambda表达式之初体验&lt;/h2&gt;&lt;p&gt;最近在重新系统地学习Python这门语言，在学习关于数据结构中的列表构造部分时，里面也有提到Lambda表达式，不过只是浅尝辄止罢了，加上之前Java（8以上的版本才支持）里面也有用到过Lambda这个东西，索性单独学习并记录之。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://thecoy.github.io/tags/Java/"/>
    
      <category term="Python" scheme="http://thecoy.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Sumo仿真</title>
    <link href="http://thecoy.github.io/2017/06/24/Sumo%E4%BB%BF%E7%9C%9F/"/>
    <id>http://thecoy.github.io/2017/06/24/Sumo仿真/</id>
    <published>2017-06-24T15:25:45.000Z</published>
    <updated>2018-11-21T15:40:22.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SUMO-仿真学习笔记"><a href="#SUMO-仿真学习笔记" class="headerlink" title="SUMO 仿真学习笔记"></a>SUMO 仿真学习笔记</h1><h2 id="仿真方案的一般步骤"><a href="#仿真方案的一般步骤" class="headerlink" title="仿真方案的一般步骤"></a>仿真方案的一般步骤</h2><p>1.创建网络</p><ul><li>使用Netgen生成抽象网络</li><li>通过xml文件自定义配置网络，然后用Netconvert 导入</li><li>使用Netconvert导入已存在的网络（OSM地图）</li></ul><a id="more"></a><p>2.需求建模</p><ul><li>描述明确的车辆路径</li><li>仅使用车流和转弯概率</li><li>生成随机路径</li><li>导入OD矩阵格式</li><li>导入已存在路径</li></ul><p>3.计算动态用户分配<br>4.校正仿真<br>5.执行仿真</p><h3 id="1-SUMO道路网络的构建"><a href="#1-SUMO道路网络的构建" class="headerlink" title="1. SUMO道路网络的构建"></a>1. SUMO道路网络的构建</h3><p><strong>网络格式</strong></p><ul><li>Sumo 道路网络是个有向图</li><li>节点代表道路交叉口</li><li>边代表道路或街道</li></ul><p><strong>边和车道</strong></p><ul><li>ID：边的标识</li><li>From：起始节点的ID</li><li>To：终止节点的ID</li><li>Priority：道路的优先级</li><li>Function:抽象边的用途（目的）<ul><li>normal:普通边，如高速公路或链接两条道路的街道</li><li>connector:微观连接器，并不是真实世界道路网络的一部分</li><li>internal:这类“边”是交叉口的一部分（在交叉口内部）</li></ul></li></ul><p><strong>1.1 使用XML文件构建自定义道路网络</strong></p><ul><li>节点的描述<br>节点文件一般以”.nod.xml”作为扩展名，每行描述一个节点，如下所示：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">id</span>=<span class="string">"&lt;STRING&gt;"</span> <span class="attr">x</span>=<span class="string">"&lt;FLOAT&gt;"</span> <span class="attr">y</span>=<span class="string">"&lt;FLOAT&gt;"</span> [<span class="attr">type</span>=<span class="string">"&lt;TYPE&gt;"</span>]/&gt;</span></span><br></pre></td></tr></table></figure><p>Type为可选字段，代表节点的类型，其取值及含义如下所示:</p><table><thead><tr><th>Type</th><th>对应含义</th></tr></thead><tbody><tr><td>priority</td><td>车辆必须等待，直到它们右侧车辆完全通过路口</td></tr><tr><td>traffic_light</td><td>交叉口被交通灯控制</td></tr><tr><td>right_before_left</td><td>来自右边的车辆优先通过</td></tr></tbody></table><p>一个节点描述示例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">x</span>=<span class="string">"-500.0"</span> <span class="attr">y</span>=<span class="string">"0.0"</span> <span class="attr">type</span>=<span class="string">"priority"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>边的描述<br>边和节点的描述差不多，但还有其他参数。边的描述格式如下所示：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">edge</span> <span class="attr">id</span>=<span class="string">"&lt;STRING&gt;"</span> (<span class="attr">fromnode</span>=<span class="string">"&lt;NODE_ID&gt;"</span> <span class="attr">tonode</span>=<span class="string">"&lt;NODE_ID&gt;"</span> | <span class="attr">xfrom</span>=<span class="string">"&lt;FLOAT&gt;"</span> <span class="attr">yfrom</span>=<span class="string">"&lt;FLOAT&gt;"</span> <span class="attr">xto</span>=<span class="string">"&lt;FLOAT&gt;"</span> <span class="attr">yto</span>=<span class="string">"&lt;FLOAT&gt;"</span>)  [<span class="attr">type</span>=<span class="string">"&lt;STRING&gt;"</span> | <span class="attr">nolanes</span>=<span class="string">"&lt;INT&gt;"</span> <span class="attr">speed</span>=<span class="string">"&lt;FLOAT&gt;"</span> <span class="attr">priority</span>=<span class="string">"&lt;UINT&gt;"</span> <span class="attr">length</span>=<span class="string">"&lt;FLOAT&gt;"</span>)][<span class="attr">shape</span>=<span class="string">"&lt;2D_POINT&gt; [ &lt;2D_POINT&gt;]*"</span>] [<span class="attr">spread_type</span>=<span class="string">"center"</span>]/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>每个边都是单向的：从起始节点开始，在终 止节点结束。如果所给出的节点名字不能提取(因为在节点文件中没有定义)，将会产生错误。</p><p>对每条边，应提供更多的属性，如拥有的车道数，允许的最大车速，边的长度(米)。而 且，还可以定义优先级(可选)。所有这些值（除了长度），可以使用相关的属性值给出，或 者给边一个类型以省略它们。</p><p>边的属性如下：</p><table><thead><tr><th>属性名</th><th>值类型</th><th>描述</th></tr></thead><tbody><tr><td>ID</td><td>string</td><td>边的名字</td></tr><tr><td>fromnode</td><td>参考node_id</td><td>边的起始节点，需在节点文件中存在</td></tr><tr><td>tonode</td><td>参考node_id</td><td>边的终止节点，需在节点文件中存在</td></tr><tr><td>type</td><td>参考type_id</td><td>类型名</td></tr><tr><td>nolanes</td><td>int</td><td>边的车道数，必须是整数</td></tr><tr><td>speed</td><td>float</td><td>边允许的最大车速(m/s)，必须是浮点数</td></tr><tr><td>priority</td><td>int</td><td>边的优先权</td></tr><tr><td>length</td><td>float</td><td>边长(m)</td></tr><tr><td>shape</td><td>位置列表，用(x1,y1,x2,y2)表示，单位m</td><td>例如：<code>&lt;edge id=&quot;e1&quot; fromnode=&quot;0&quot; tonode=&quot;1&quot; shape=&quot;0,0 0,100&quot;/&gt;</code> 描述一个边， 从节点0开始，首先经过点(0,0)，然后向右行 100米，最后到达节点1</td></tr><tr><td>spread_type</td><td>枚举类型（right,center）</td><td>描述怎样延展车道，center表示双向延展车道， 其他值为右向延展 </td></tr></tbody></table><p>一条边的描述示例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">edge</span> <span class="attr">id</span>=<span class="string">"2o"</span> <span class="attr">fromnode</span>=<span class="string">"0"</span> <span class="attr">tonode</span>=<span class="string">"2"</span> <span class="attr">priority</span>=<span class="string">"1"</span> <span class="attr">nolanes</span>=<span class="string">"1"</span> <span class="attr">speed</span>=<span class="string">"11.11"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>使用Netconvert构建网络调用格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netconvert --xml-node-files=MyNodes.nod.xml --xml-edge-files=MyEdges.edg.xml --output-file=MySUMONet.net.xml</span><br></pre></td></tr></table></figure></li></ul><p>如果还使用了类型和连接文件，则调用格式如下：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netconvert --xml-node-files=MyNodes.nod.xml --xml-edge-files=MyEdges.edg.xml --xml-connection-files=MyConnections.<span class="built_in">con</span>.xml --xml-<span class="built_in">type</span>-files=MyTypes.typ.xml --output-file=MySUMONet.<span class="built_in">net</span>.xml</span><br></pre></td></tr></table></figure></p><p>可能你的边的定义不完整或有错，如果你仍希望导入这个网络，可以试着使用 NETCONVERT的–dismiss-loading-errors参数忽略这些。这样，定义不正确的边将被省略， 但是NETCONVERT仍试图构建网络。</p><p><strong>1.2 OpenStreetMap格式的路网导入</strong></p><p>从OpenStreetMap的<a href="http://www.openstreetmap.org/" target="_blank" rel="noopener">官方网站</a>可以知道， OpenStreetMap是一个可自由编辑的世界地图，它由来自全世界的人士共同编辑维护。 OpenStreetMap工程的地图数据文件是一个或多个XML文件。 注意：OSM数据可以有多种不同的方式下载获得。</p><p>NETCONVERT可以导入本地的OSM数据文件，这需要使用选项—osm-files \<file> 下面的命令导入OSM格式路网文件berlin.osm.xml，并把产生的SUMO路网文件保存为 berlin.net.xml：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netconvert --osm-files berlin.osm.xml -o berlin.<span class="built_in">net</span>.xml</span><br></pre></td></tr></table></figure></file></p><p>注意：导入OSM路网后，一个路口节点可能被分为很多歌节点，这样既不美观，也影响 仿真效果，我们可以合并距离较近的节点，或者指定合并哪些节点，具体如下：<br> <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netconvert --osm-files map.osm --junctions.join-dist <span class="number">50</span> -o guiyang.<span class="built_in">net</span>.xml</span><br></pre></td></tr></table></figure></p><hr><h3 id="2-需求建模"><a href="#2-需求建模" class="headerlink" title="2. 需求建模"></a>2. 需求建模</h3><p> 在产生路网之后，我们通过GUISIM可以发现，并没有车辆运行。我们还需要对车辆进行一些描述，于是有了如下关于旅程和路径的定义：</p><ul><li>旅程(trip) —— 旅程是车辆从一地到另一地的移动，由起始边，目的边和所用时间的定义 </li><li>路径(route) —— 路径是扩展的旅程，这就是说路径的定义不仅包含起止边，还包括车俩将 通过的所有的边。SUMO和GUISIM需要路径作为车辆移动的输入数据。有多种方法可以为 SUMO生产路径信息</li></ul><p>Sumo中用于处理路径信息的工具：</p><ol><li>Duarouter —— 负责从其他仿真软件包导入路径或定义，并使用Dijkstra的最短路径算 法计算路径。另外与仿真相结合，DUAROUTER程序可以计算动态用户分配(C. Gawron的模 型)</li><li>Jtrrouter —— 使用交叉口的转弯率来静态的建模交通</li><li>Od2trips —— 用于转换OD矩阵到旅程信息</li><li>Dfrouter —— 从所给的观察点的度量计算路径</li></ol><p><strong>可行的生成随机路径的方法</strong><br>1.使用sumo\tools\trip目录下的randomTrips.py脚本生成*.trip.xml随机旅程文件(net 文件作为输入)<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomTrips.py  –n  beijing.<span class="built_in">net</span>.xml</span><br></pre></td></tr></table></figure></p><p>2.使用Duarouter工具(使用net文件和trip文件作为输入)生成路径文件<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duarouter  –n test.<span class="built_in">net</span>.xml  –t test.trip.xml  –o test.rou.xml --continue-on-unbuild(忽略错误继续) –w(不显示警告信息)</span><br></pre></td></tr></table></figure></p><hr><h3 id="3-可行的仿真方案"><a href="#3-可行的仿真方案" class="headerlink" title="3. 可行的仿真方案"></a>3. 可行的仿真方案</h3><p><strong>3.1  使用随机路径仿真</strong><br>1.在OpenStreetMap网站下载osm格式的城市地图<br>2.使用netconvert把osm格式地图转换为SUMO格式的路网:<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netconvert --osm-files berlin.osm.xml -o berlin.<span class="built_in">net</span>.xml</span><br></pre></td></tr></table></figure></p><p>3.使用sumo\tools\trip目录下的randomTrips.py脚本生成*.trip.xml随机旅程文件(net 文件作为输入)，以下命令生成berlin.trip.xml随机旅程文件:<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomTrips.py  –n  berlin.<span class="built_in">net</span>.xml</span><br></pre></td></tr></table></figure></p><p>4.使用Duarouter工具(使用net文件和trip文件作为输入)生成路径文件(也可使用车 辆定义文件)<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duarouter  –n berlin.<span class="built_in">net</span>.xml  –t berlin.trip.xml  –o berlin.rou.xml --continue-on-unbuild(忽略错误继续) –w(不显示警告信息)</span><br></pre></td></tr></table></figure></p><p>5.手工编辑berlin.sumo.cfg配置文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">net-file</span> <span class="attr">value</span>=<span class="string">"berlin.net.xml"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">route-files</span> <span class="attr">value</span>=<span class="string">"berlin.rou.xml"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--产生的polygon文件berlin.poly.xml需要添加进sumo-gui配置里面： --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">additional-files</span> <span class="attr">value</span>=<span class="string">"berlin.poly.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">output</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">vehroute-output</span> <span class="attr">value</span>=<span class="string">"vehroutes.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">output</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">report</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">no-duration-log</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span> <span class="tag">&lt;<span class="name">no-step-log</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">report</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>6.在可视化仿真工具sumo-gui中打开berlin.sumo.cfg配置文件，点击运行仿真按钮即可开始仿真</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SUMO-仿真学习笔记&quot;&gt;&lt;a href=&quot;#SUMO-仿真学习笔记&quot; class=&quot;headerlink&quot; title=&quot;SUMO 仿真学习笔记&quot;&gt;&lt;/a&gt;SUMO 仿真学习笔记&lt;/h1&gt;&lt;h2 id=&quot;仿真方案的一般步骤&quot;&gt;&lt;a href=&quot;#仿真方案的一般步骤&quot; class=&quot;headerlink&quot; title=&quot;仿真方案的一般步骤&quot;&gt;&lt;/a&gt;仿真方案的一般步骤&lt;/h2&gt;&lt;p&gt;1.创建网络&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Netgen生成抽象网络&lt;/li&gt;
&lt;li&gt;通过xml文件自定义配置网络，然后用Netconvert 导入&lt;/li&gt;
&lt;li&gt;使用Netconvert导入已存在的网络（OSM地图）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="SUMO" scheme="http://thecoy.github.io/tags/SUMO/"/>
    
  </entry>
  
  <entry>
    <title>Java foreach循环遍历操作</title>
    <link href="http://thecoy.github.io/2017/05/31/Java-foreach%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C/"/>
    <id>http://thecoy.github.io/2017/05/31/Java-foreach循环遍历操作/</id>
    <published>2017-05-31T12:22:12.000Z</published>
    <updated>2018-11-21T15:40:22.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先贴一段会报异常的代码"><a href="#先贴一段会报异常的代码" class="headerlink" title="先贴一段会报异常的代码"></a>先贴一段会报异常的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"first"</span>);</span><br><span class="line">        list.add(<span class="string">"second"</span>);</span><br><span class="line">        list.add(<span class="string">"third"</span>);</span><br><span class="line">        list.add(<span class="string">"fourth"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"first"</span>.equals(str))</span><br><span class="line">                list.remove(str);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上代码会报java.util.ConcurrentModificationException这个异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure></p><a id="more"></a><p> for(String str:list)　这句话实际上是用到了集合的iterator() 方法,一般我们也会经常用到iterator来遍历集合，但是一旦设计到对元素进行修改（CRUD）的时候就需要格外注意了，具体一看源码便知：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--java.util. AbstractList的内部类Itr的源码--&gt;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();  </span><br><span class="line">           checkForComodification();  </span><br><span class="line"> </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           AbstractList.<span class="keyword">this</span>.remove(lastRet); <span class="comment">//执行remove的操作  </span></span><br><span class="line">           <span class="keyword">if</span> (lastRet &lt; cursor)  </span><br><span class="line">             cursor--;  </span><br><span class="line">           lastRet = -<span class="number">1</span>;  </span><br><span class="line">           expectedModCount = modCount; <span class="comment">//保证了modCount和expectedModCount的值的一致性，避免抛出ConcurrentModificationException异常  </span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123; </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (modCount != expectedModCount) <span class="comment">//当modCount和expectedModCount值不相等时，则抛出ConcurrentModificationException异常  </span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 然而，ArrayList的remove方法是这样的：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </span><br><span class="line">        <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            fastRemove(index);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </span><br><span class="line">        <span class="keyword">if</span> (o.equals(elementData[index])) &#123;  </span><br><span class="line">            fastRemove(index);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not </span></span><br><span class="line"><span class="comment">     * return the value removed. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        modCount++; <span class="comment">//只是修改了modCount，因此modCount将与expectedModCount的值不一致  </span></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </span><br><span class="line">            System.arraycopy(elementData,index+<span class="number">1</span>,elementData,index,numMoved);  </span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work  </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>通过阅读源码即可知道，ArrayList的remove方法只是修改了modCount的值，并没有修改expectedModCount，导致modCount和expectedModCount的值的不一致性，当next()时则抛出ConcurrentModificationException异常。因此使用Iterator遍历集合时，不要改动被迭代的对象，可以使用 Iterator 本身的方法 remove() 来删除对象，Iterator.remove()方法会在删除当前迭代对象的同时维护modCount和expectedModCount值的一致性。</li></ul><ul><li>另外注意如果是如下的情况又不会报异常：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"first"</span>);</span><br><span class="line">        list.add(<span class="string">"second"</span>);</span><br><span class="line">        list.add(<span class="string">"third"</span>);</span><br><span class="line">        list.add(<span class="string">"fourth"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String str: list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"third"</span>.equals(str))</span><br><span class="line">                list.remove(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>这是因为在删除倒数第二个元素的时候，cursor指向最后一个元素的，而此时删掉了倒数第二个元素后，cursor和size()正好相等了，所以hasNext()返回false，遍历结束，于是也就不会进入到next（）执行checkForComodification检查了，所以也就不会报异常。</li><li><p>最后，回到本文的主题，foreach（）循环遍历的正确打开方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"first"</span>);</span><br><span class="line">        list.add(<span class="string">"second"</span>);</span><br><span class="line">        list.add(<span class="string">"third"</span>);</span><br><span class="line">        list.add(<span class="string">"fourth"</span>);</span><br><span class="line">        list.add(<span class="string">"five"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String temp = it.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"five"</span>.equals(temp))</span><br><span class="line">                it.remove();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>不过对于在多线程环境下对集合类元素进行迭代修改操作，最好把代码放在一个同步代码块内，这样才能保证modCount和expectedModCount的值的一致性，类似如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();    </span><br><span class="line"><span class="keyword">synchronized</span>(synObject) &#123;  </span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext()) &#123;    </span><br><span class="line">        String str = iterator.next();    </span><br><span class="line">        <span class="keyword">if</span>(del.contains(str)) &#123;    </span><br><span class="line">            iterator.remove();    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先贴一段会报异常的代码&quot;&gt;&lt;a href=&quot;#先贴一段会报异常的代码&quot; class=&quot;headerlink&quot; title=&quot;先贴一段会报异常的代码&quot;&gt;&lt;/a&gt;先贴一段会报异常的代码&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;String&amp;gt; list = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;string&quot;&gt;&quot;first&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;string&quot;&gt;&quot;second&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;string&quot;&gt;&quot;third&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;string&quot;&gt;&quot;fourth&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(String str:list)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;first&quot;&lt;/span&gt;.equals(str))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                list.remove(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(list.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如上代码会报java.util.ConcurrentModificationException这个异常：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Exception in thread &amp;quot;main&amp;quot; java.util.ConcurrentModificationException&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://thecoy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java装拆箱</title>
    <link href="http://thecoy.github.io/2017/05/24/Java%E8%A3%85%E6%8B%86%E7%AE%B1/"/>
    <id>http://thecoy.github.io/2017/05/24/Java装拆箱/</id>
    <published>2017-05-24T12:47:33.000Z</published>
    <updated>2018-11-21T15:40:22.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于Java装拆箱与包装类型的学习"><a href="#关于Java装拆箱与包装类型的学习" class="headerlink" title="关于Java装拆箱与包装类型的学习"></a>关于Java装拆箱与包装类型的学习</h2><h3 id="Java的包装类"><a href="#Java的包装类" class="headerlink" title="Java的包装类"></a>Java的包装类</h3><blockquote><p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)，有些地方也翻译为外覆类或数据类型类，如下表所示：</p></blockquote><a id="more"></a><table><thead><tr><th>基本数据类型</th><th>对应的包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h4 id="Java-包装器类的主要目的"><a href="#Java-包装器类的主要目的" class="headerlink" title="Java 包装器类的主要目的"></a>Java 包装器类的主要目的</h4><ul><li>提供一种机制，将基本值“包装”到对象中，从而使基本值能够包含在为对象而保留的操作中，比如添加到Collections 中，或者从带对象返回值的方法中返回。</li><li>为基本值提供分类功能。这些功能大多数于各种转换有关：在基本值和String对象间相互转换，在基本值和String对象之间按不同基数转换，如二进制、八进制和十六进制。</li></ul><hr><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>在Java SE5之前，如果要生成一个数值为100的Integer对象，必须这样进行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p><p>而从Java SE5开始提供了自动装箱的特性，上述代码可写成如下形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></p><p>那么在这个过程中会自动根据数值创建对应的Integer对象，这就是<strong><em>装箱</em></strong>，自动调用Integer的valueOf()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer test = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> f = test.initValue();</span><br></pre></td></tr></table></figure></p><p>而以上则就是所谓的<strong><em>拆箱</em></strong>，自动调用Integer的intValue（）方法。于是，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装箱--&gt;自动将基本数据类型转换为包装器类型</span><br><span class="line">拆箱--&gt;自动将包装器类型转换为基本数据类型</span><br></pre></td></tr></table></figure><hr><h3 id="与之相关的坑与警示"><a href="#与之相关的坑与警示" class="headerlink" title="与之相关的坑与警示"></a>与之相关的坑与警示</h3><ul><li>由于最近在看《阿里巴巴JAVA开发手册》，在（4）OOP规约的第7条中提到，<blockquote><ol start="7"><li>【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 </li></ol></blockquote></li></ul><p>究竟是什么原因让阿里的程序猿们如此深恶痛觉，其实只需一看源码便知晓答案了，下面这段代码是Integer的valueOf方法的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntergerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>说明：对于 Integer var=?在-128 至 127 之间的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行 判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑， 推荐使用 equals 方法进行判断</li></ul><hr><h3 id="一些关于装箱与拆箱的面试题"><a href="#一些关于装箱与拆箱的面试题" class="headerlink" title="一些关于装箱与拆箱的面试题"></a>一些关于装箱与拆箱的面试题</h3><ul><li>这里，先通过下面的表格弄清楚“==”和equals()的区别.</li></ul><table><thead><tr><th>基本数据类型</th><th>==</th><th>equals()</th></tr></thead><tbody><tr><td>字符串变量</td><td>对象内存地址</td><td>字符串内容</td></tr><tr><td>非字符串变量</td><td>对象内存地址</td><td>对象内存地址</td></tr><tr><td>基本类型</td><td>值</td><td>不可用</td></tr><tr><td>包装类</td><td>对象内存地址</td><td>内容</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        Integer i3 = <span class="number">200</span>;</span><br><span class="line">        Integer i4 = <span class="number">200</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出结果：</span></span><br><span class="line"><span class="comment">* true</span></span><br><span class="line"><span class="comment">* false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>参照以上Integer的valueOf()方法的源码不难理解上述的输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double i1 = <span class="number">100.0</span>;</span><br><span class="line">        Double i2 = <span class="number">100.0</span>;</span><br><span class="line">        Double i3 = <span class="number">200.0</span>;</span><br><span class="line">        Double i4 = <span class="number">200.0</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出结果：</span></span><br><span class="line"><span class="comment">* false</span></span><br><span class="line"><span class="comment">* false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出结果：</span></span><br><span class="line"><span class="comment">* true</span></span><br><span class="line"><span class="comment">* true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上结果参照Boolean类的源码也会一目了然：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>以及TRUE 和 FALSE的定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment"> * value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment"> * value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于Java装拆箱与包装类型的学习&quot;&gt;&lt;a href=&quot;#关于Java装拆箱与包装类型的学习&quot; class=&quot;headerlink&quot; title=&quot;关于Java装拆箱与包装类型的学习&quot;&gt;&lt;/a&gt;关于Java装拆箱与包装类型的学习&lt;/h2&gt;&lt;h3 id=&quot;Java的包装类&quot;&gt;&lt;a href=&quot;#Java的包装类&quot; class=&quot;headerlink&quot; title=&quot;Java的包装类&quot;&gt;&lt;/a&gt;Java的包装类&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)，有些地方也翻译为外覆类或数据类型类，如下表所示：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://thecoy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>2017-05-06diary</title>
    <link href="http://thecoy.github.io/2017/05/06/2017-05-06diary/"/>
    <id>http://thecoy.github.io/2017/05/06/2017-05-06diary/</id>
    <published>2017-05-06T11:46:55.000Z</published>
    <updated>2018-11-21T15:40:22.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017-05-06"><a href="#2017-05-06" class="headerlink" title="2017-05-06"></a>2017-05-06</h2><p>之前很久就想弄这个Blog了，但一直各种事情缠身，终于花了近一天的时间搭了个雏形，非常感谢<strong>Litten</strong>提供的这个主题 <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">yilia</a>，很喜欢它，虽然不是一枚前端猿，但其实发现能够自己折腾折腾做些好玩又好看的东西也还蛮有意思的，所以后面也还是会继续不断地折腾，向大神学习，一点点的进步！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2017-05-06&quot;&gt;&lt;a href=&quot;#2017-05-06&quot; class=&quot;headerlink&quot; title=&quot;2017-05-06&quot;&gt;&lt;/a&gt;2017-05-06&lt;/h2&gt;&lt;p&gt;之前很久就想弄这个Blog了，但一直各种事情缠身，终于花了近一天的时间搭了个
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://thecoy.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>坚持不懈</title>
    <link href="http://thecoy.github.io/2012/07/21/%E5%9D%9A%E6%8C%81%E4%B8%8D%E6%87%88/"/>
    <id>http://thecoy.github.io/2012/07/21/坚持不懈/</id>
    <published>2012-07-21T14:39:32.000Z</published>
    <updated>2019-10-21T14:42:12.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="所谓“坚持不解”"><a href="#所谓“坚持不解”" class="headerlink" title="所谓“坚持不解”"></a>所谓“坚持不解”</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    首先申明一下，题目没有打错，也不是编码出了问题，算是我故意为之吧。因为前几天在网上看见了一个名为“坚持不懈”的ID，结果不知怎</span><br><span class="line">么突然头晕眼花的我竟然将它 看成“坚持了解”了。起初只感到惭愧，后来忍不住思绪在脑海里来回几个翻滚，愈想愈觉得这无疑是一种美丽的错</span><br><span class="line">误。</span><br><span class="line">    时间退回到高中甚至是初中时代，我的理解是别人都一直认为我是一个老实、勤奋、刻苦的好学生，事实是在今天我自己看来也却实如此。</span><br><span class="line">在那些个备战中高考的紧张日子里，我确实是想把自己“打造”成一个坚持不懈的人，然后期待一次无与伦比的华丽丽的绽放，结果都只能无疾而</span><br><span class="line">终，左后我都耐不住想要严刑拷打自己了，尽管这似乎是一个绝妙的矛盾。也是直到后来，我才明白这可能称为一种叫做“拖延心理”的东西。</span><br><span class="line">    前段时间又稍微了解了一下“积极心理学”，它的一个观点引起了我巨大的共鸣。他鼓励我们在期许达到某个目标的时候，尽量使用积极的词</span><br><span class="line">汇而非消极的词汇，比如用“神啊，保佑我吧”就比“神啊，可千万别抛弃我啊”要好一些，哦不，是好很多。而我对此的理解是，上帝可能只能理</span><br><span class="line">解我祈祷中的非修饰性本分，因为在我在向上帝单向传递信息的这样由模型实例化的会话过程中，我与上帝的协议中并没有申明对像“不、NO、</span><br><span class="line">非”一类的解析方式，就像你让一个可爱憨厚的种地的农民伯伯去解读一下“!零”的含义是什么一样，他可能就会给你类似“哦，它（!零）啊，我</span><br><span class="line">辛勤劳作、付出汗水，然后我今年的收成就不会!零咯”的回应，结果只能是啼笑皆非了。所以当我的例程中没有类似TCP/IP协议的可供参考的指</span><br><span class="line">引时，我就只能最好发出正面的祈祷在收获美好愿望的同时避免上帝给我开一个大大的玩笑并让我hold不住。</span><br><span class="line">    于是，我似乎开始懂了，“坚持了解”应该比“坚持不懈”要好的多，在我期盼能够坚持了解 的时候，上帝就能够正确解读并响应我的请求</span><br><span class="line">了。而如果我发出坚持不懈的请求时，噢，惨了，上帝看见了‘懈’，不幸的是'不'却被遗忘在某个肮脏不堪的垃圾桶（上帝专用）里去了。</span><br><span class="line">“噢，My god，你为何如此对我啊”也终于成了我苦不堪言的悲叹。其实，细细想来，尽管上述内容有点虚无缥缈，可我还是最终屈服了“用坚持</span><br><span class="line">了解要比坚持不懈好”的观点，坚持了解有什么不好的呢？坚持每天了解一些编程技术及思想难道不比夸下一个“三天搞定欧洲文学史”的海口要来</span><br><span class="line">得更好一点么？当然如果对于智商三倍于爱因斯坦的人来说，我愿意听从他的命令——抱着我的这个观点然后去面朝大海。坚持了解也似乎更能有</span><br><span class="line">助于我的兴趣的增加与知能的提升，我可以为我每一天的进步而不断加油，在我乘着我化大为小的帆船里，漫漫汪洋任我一帆风顺的前行。我不</span><br><span class="line">用再为我那遥不可及的目标望洋欣叹，并且一任我的暴躁与气馁的气焰上涨，而且最终又陷入自己被自己打败的尴尬又矛盾的境地里。</span><br><span class="line">    所以，我更乐意把坚持了解递交给GOD，而坚持不懈就留给自己在老家的旧房子里的某个暗黑的小匣子中，让它好好地睡上一觉吧！哦不，</span><br><span class="line">是永久性地休眠，因为你无法杀死它...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;所谓“坚持不解”&quot;&gt;&lt;a href=&quot;#所谓“坚持不解”&quot; class=&quot;headerlink&quot; title=&quot;所谓“坚持不解”&quot;&gt;&lt;/a&gt;所谓“坚持不解”&lt;/h3&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://thecoy.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>我们没有们</title>
    <link href="http://thecoy.github.io/2012/07/21/%E6%88%91%E4%BB%AC%E6%B2%A1%E6%9C%89%E4%BB%AC/"/>
    <id>http://thecoy.github.io/2012/07/21/我们没有们/</id>
    <published>2012-07-21T14:33:08.000Z</published>
    <updated>2019-10-21T14:36:29.433Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    前段时间开始考虑准备写blog的事情，思来想去，冥冥之中总觉得还有什么问题没解决好，后来翻看了自己以前的“字符堆栈之后，猛然发</span><br><span class="line">现‘我’的后面莫名其妙地多出来一个‘们’。虽然问题是找出来了，可又觉得解决起来可能得花费一点时间，因为在这个问题之前的另外一个问题</span><br><span class="line">足足花了我近半年的时间。</span><br><span class="line">    那会儿似乎还是小学的时候，奉语文老师之命，每周得‘憋’出至少三篇日记出来，所幸深谙“流水文”之法，这点任务还算小case，可偏偏</span><br><span class="line">每周拿去检查时，都能给检查出不少于五个错别字来，尽管它们都是‘我’的克隆体，而且我是屡犯屡改，然后屡改屡犯，最后连都老师都只能</span><br><span class="line">speechless了。千万别怀疑我是故意的，我当时一想，感觉这这问题挺严重的啊！因为这似乎关乎着我能否作好一个人和面对自我的问题，要</span><br><span class="line">是真改不过来了，我想我宁愿做个文盲也不要去写个错别字－－少了一撇的‘我’。后来换了老师，我突然在少了提醒的情况下奇迹般给纠正了过来。而我也由此得出一个结论：自我的觉醒要胜过他人的提醒万倍。</span><br><span class="line">    如果说上次由于‘我’内部的叛变引发了我跟它之间旷日持久的战阵，那么这一次‘我’于‘们’的强强联手又教我如何应对呢？‘们’给了我</span><br><span class="line">关于乱给别人贴标签的错误当头一棒，的确，我老是自以为别人和我都有着共同的且称之为缺点的东西，然后无情地先把他们打入十八层地狱，</span><br><span class="line">然后装作智者模样给他们指引明确的方向。难道我真的是普度天下众生从西天取得真经回来的唐僧么？如果真是，那么我想西天确乎去过，只是</span><br><span class="line">没有回来而已，至于是否取得真经也就不得而知了。‘们’还给了我自我标榜不凡、不可一世、孤傲自大的一声严厉喝斥，我还只不过是个刚成年</span><br><span class="line">的社会青年而已，没有任何社会阅历的我凭什么就可能秀口一吐就句句皆醒世名言呢？我尚能吐出来的不过是几句中国式英语和电磁感应定律而</span><br><span class="line">已，连我自己都为之汗颜…</span><br><span class="line">    所以，英勇的‘们’，我宣布无条件向您投降，请求您撤回您的驻军吧，从此我再也不打扰您了…</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://thecoy.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>坐文章</title>
    <link href="http://thecoy.github.io/2012/07/21/%E5%9D%90%E6%96%87%E7%AB%A0/"/>
    <id>http://thecoy.github.io/2012/07/21/坐文章/</id>
    <published>2012-07-21T14:22:09.000Z</published>
    <updated>2019-10-21T14:36:27.994Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    小时候坐车特容易晕，爷爷说坐前排不会晕，所以从此坐车就一直有坐前排的习惯。晕车的滋味似乎和劣质塑料袋的味道绑在一起，印象中</span><br><span class="line">晕得最厉害的是一次坐那种黑色的小轿车去小姨的婚礼，上车前爷爷给司机说了情况然后让我坐在前排，还有备无患似地递给我几个塑料袋，至</span><br><span class="line">今我都怀疑我是闻了那个塑料袋的味道后才大吐特吐的，结果是我从上车后约20分钟后就在一边吐一边闻这永生难忘的味道的模式中痛苦地挣扎</span><br><span class="line">着，约摸一趟课的时间之后，顿觉荡气回肠，泪眼婆娑，头脑中的思绪终于从外太空飘回了地球，我诧异于这样一种制造痛苦的方式若在革命时</span><br><span class="line">期可能会迫使我屈服于敌人，当然你可以说我不忠于革命什么之类的，但那种难受确实一生难忘。</span><br><span class="line">    似乎写着写着就有些偏题了，还是回归正题。不过说来也怪，虽然后来一直比较恐惧坐车，但坐公交以来就还真没晕过，可能是坐车的“技</span><br><span class="line">术”越来越高了吧。然后貌似坐车是件很无聊的事情，接着思绪就开始漫天飞舞了。说来也怪，我许多的道理都是在这样一个过程中悟出来的，说</span><br><span class="line">是道理，其实大多也就是自己的一些胡思乱想，勉强算作我对于人生的一些微不足道的探索。初中时候由于占地理优势的原因，我一直都能先于</span><br><span class="line">同学坐上开往学校的所谓“班车”，然后我会毫不犹豫地选择坐在最前排，相当于副驾驶员的位置，尽管事实是我只是个摆设而已，可同学们就立</span><br><span class="line">马给出了一个时髦的解说－代言人，对，没错，谁说运营列车就不能有代言人呢？我笑笑，然后沉默，继续着我的“探索”，在这个连续变幻的社</span><br><span class="line">会中，每次都会有不同的人，不同的事，不同的感受，然后得出各种各样的结论，就像每天作各种各样的作业，然后掌握各种解题方法，有时候</span><br><span class="line">会有似乎面朝大海时的超脱，哪怕只有很小一段，我却仍然不放弃每一次能够这样陶醉自己的机会。</span><br><span class="line">    后来像那样坐车少了，每次都试图把握住然后结出一点精华，可都无功且下车。然后有了移动工具，我获得了不让它流逝的方法，就像现在</span><br><span class="line">这样记录下来所思所想，然后就坐出勉强称之文章的东西来了…</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://thecoy.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>那些年</title>
    <link href="http://thecoy.github.io/2012/07/21/%E9%82%A3%E4%BA%9B%E5%B9%B4/"/>
    <id>http://thecoy.github.io/2012/07/21/那些年/</id>
    <published>2012-07-21T14:10:23.000Z</published>
    <updated>2019-10-21T14:21:22.350Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    看过九把刀的《那些年，我们一起追过的女孩》两遍之后，一直纠结于男女主人公之间那种类似恋爱的关系，今天突然联想起自己曾常玩的</span><br><span class="line">游戏“天龙八部”，觉得似乎有点相似的地方。</span><br><span class="line">    初三中考备战期，我阴差阳错进入特别训练场，为那仅有的二十几个指标作特殊冲刺，现在回想起来有点地下革命党的意味。出于节省时间</span><br><span class="line">的考虑，就在补课点周围和一位“志同道合”之友一起租住了一间八平房。那会儿刚接触电脑，有时为能在网吧等到一个位置而暗自高兴许久，尽</span><br><span class="line">管连首mp3都不会下载，却依然痴迷于《侠盗列车》里为所欲为的畅快。在这之前，有时甚至连周末放假回家和坐车的一小时间隔中，都会义无反</span><br><span class="line">顾地冒着错过唯一一班客车的危险跑到网吧象抽吸鸦片般一解一个多星期来的瘾。所以当我明白补课可以增加我上网时间期望值的时候，我再次</span><br><span class="line">义无反顾地选择了拉近自己与电脑的物理距离，但补课却还没有完全沦为一个幌子，因为从后来的结果来看，至少我的家人都觉得所谓的努力没</span><br><span class="line">有白费。</span><br><span class="line">    而真正让我沉迷于网络的恐怕要属于《天龙八部一》了，而且我也幸感那年天龙还没二。尽管它不是我调试的第一个程序，但我却深深地沉</span><br><span class="line">入其中无法自拔，而且一沉就还是三年，时间恰恰刚好从初三的暑假到高三的暑假，像一个轮回。从最开始第一眼被它打怪的动作所吸引，我就</span><br><span class="line">知道了这里有着一个全新的世界将等待着我去探索。然后就是在我那位道友的指引下，我开始走上了在游戏世界里打怪－任务－升级－装备的循</span><br><span class="line">环之路，不断地成长。后来家里终于买了电脑，我也可以夜以继日地疯狂地练级、挣钱了，哪怕我熬夜到四、五点只为刷怪物头目得万灵石然后</span><br><span class="line">换那么几件装备；哪怕我顶着疲惫的身体目不转睛地盯着屏幕然后操纵着角色从这个城市跑到那个城市，最后辛苦地跑完八趟商得到那可怜的不</span><br><span class="line">到一块钱就能换得的等值的游戏币；哪怕我的双眼看这个原本清晰的世界日益模糊，我还是盯着满‘世界’不断刷新的信息以收购自己想要的东</span><br><span class="line">西，有时甚至不惜口舌地讨价还价上半天…直到现在看着游戏就满生厌恶之情时才发现，只是如果没有那些哪怕，可能也就像囫囵吞枣后回忆枣的</span><br><span class="line">味道一样…</span><br><span class="line">    也是现在我也才开始明白，从相识到熟识之间的过程是美好的，而之后的感觉就像饱食后品尝美味的滋味终究比不上饥饿时的一碗炒饭一</span><br><span class="line">样，所以我不后悔曾沉迷过的这样一段经历…</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://thecoy.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
