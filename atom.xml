<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TheCoy&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/4f0d97202f9939732dbd47d7b311390f</icon>
  <subtitle>做一个傻子多么好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thecoy.github.io/"/>
  <updated>2018-11-12T14:50:26.500Z</updated>
  <id>http://thecoy.github.io/</id>
  
  <author>
    <name>TheCoy</name>
    <email>coy20150428@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://thecoy.github.io/2017/08/28/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://thecoy.github.io/2017/08/28/排序算法总结/</id>
    <published>2017-08-28T07:35:45.000Z</published>
    <updated>2018-11-12T14:50:26.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>算法实现过程：筛选过程通过一个从右到左的循环实现，该循环使用变量j跟踪被筛选的元素。只要该元素具有前驱（j&gt;0）且没有达到最终位置，循环就交换该元素和它的前驱，代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(Integer[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; a[j-<span class="number">1</span>]&gt;a[j]; j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[j];</span><br><span class="line">            a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">            a[j-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：</p><ul><li>给定待排序的数列初态不同时，直接插入排序所耗费的时间有很大差异。</li><li>若初态为正序，则每个待插入的记录只需比较一次就能找到对应位置插入，此时算法的时间复杂度为O(n)。</li><li>若初态为反序，则第i个待插入记录需要比较i+1次才能找到合适位置插入，此时时间复杂度为O(n^2)。</li></ul><a id="more"></a><h3 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h3><p>基本思想：二分法插入排序的思想和直接插入一样，只是找合适的插入位置的方式不同，这里通过二分法找到合适的位置，可以减少比较的次数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BinaryInsertSort</span><span class="params">(Integer[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[mid])</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= left; j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[j];</span><br><span class="line">            a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">            a[j-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：</p><ul><li>二分插入排序的比较次数与待排序记录的初始状态无关，仅依赖记录的个数。</li><li>当n较大时，比直接插入排序的最大比较次数少得多，但大于直接插入排序的最小比较次数。</li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>基本思想：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量<code>d2&lt;d1</code>重复上述的分组和排序，直至所取的增量<code>dt=1(dt&lt;dt-l&lt;…&lt;d2&lt;d1)</code>，即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(Integer[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = nums.length;</span><br><span class="line">    <span class="keyword">while</span>(d &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        d = d/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+d;j &lt; nums.length;j = j+d)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &gt; i &amp;&amp; nums[k] &lt; nums[k-d];k = k -d)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[k];</span><br><span class="line">                    nums[k] = nums[k-d];</span><br><span class="line">                    nums[k-d] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>希尔排序的时间性能优于直接插入排序，原因如下：</p><ul><li>当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。</li><li>当n值较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0(n2)差别不大。</li><li>在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。</li></ul><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p>算法思想：每趟从待排序的记录序列中选择关键字最小的记录放置到已排序表的最前位置，直到全部排完。时间复杂度为O(n^2)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(Integer[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序算法是一个两阶段的过程：前n步将数组建立到堆中，后n步按降序提取元素并从右到左建立最终的有序序列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(Integer[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[(j-<span class="number">1</span>)/<span class="number">2</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">            nums[j] = nums[(j-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">            nums[(j-<span class="number">1</span>)/<span class="number">2</span>] = temp;</span><br><span class="line">            j = (j-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; i)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = j*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= i)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(c+<span class="number">1</span> &lt; i &amp;&amp; nums[c+<span class="number">1</span>] &gt;= nums[c])</span><br><span class="line">                c += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt;= nums[c])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> t = nums[c];</span><br><span class="line">            nums[c] = nums[j];</span><br><span class="line">            nums[j] = t;</span><br><span class="line">            j = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：</p><ul><li>堆排序也是一种不稳定的排序算法。</li><li>堆排序的最坏时间复杂度为O(nlogn)。</li><li>堆序的平均性能较接近于最坏性能。由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。</li></ul><p>堆排序的两个关键函数</p><ul><li><p>Siftup,向上筛选，heap(1,n-1)-&gt;heap(1,n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void siftup(n)</span><br><span class="line">    pre n &gt; <span class="number">0</span> &amp;&amp; heap(<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">    post heap(<span class="number">1</span>,n) </span><br><span class="line"></span><br><span class="line">    i = n</span><br><span class="line">    loop:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p = i/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span>(x[p] &lt;= x[i])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        swap(x[p],x[i])</span><br><span class="line">        i = p</span><br></pre></td></tr></table></figure></li><li><p>Siftdown,向下筛选，heap(2,n)-&gt;heap(1,n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void siftdown(n)</span><br><span class="line">    pre heap(<span class="number">2</span>,n) &amp;&amp; n &gt;= <span class="number">0</span></span><br><span class="line">    post heap(<span class="number">1</span>,n)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    loop:</span><br><span class="line">        c = <span class="number">2</span>*i</span><br><span class="line">        <span class="keyword">if</span> c &gt; n</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> c+<span class="number">1</span> &lt;= n &amp;&amp; x[c+<span class="number">1</span>] &lt; x[c]</span><br><span class="line">            c++</span><br><span class="line">        <span class="keyword">if</span> x[i] &lt;= x[c]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        swap(x[c],x[i])</span><br><span class="line">        i = c</span><br></pre></td></tr></table></figure></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(Integer[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.length-<span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">                nums[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：冒泡排序是一种稳定的排序。</p><ul><li>若文件初状为正序，则一趟起泡就可完成排序，排序码的比较次数为n-1，且没有记录移动，时间复杂度是O(n)</li><li>若文件初态为逆序，则需要n-1趟起泡，每趟进行n-i次排序码的比较，且每次比较都移动三次，比较和移动次数均达到最大值∶O(n2)</li><li>冒泡排序平均时间复杂度为O(n2)</li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(Integer[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = left;</span><br><span class="line">    <span class="keyword">int</span> t = nums[left];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left+<span class="number">1</span>; i &lt;= right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; t)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[++m];</span><br><span class="line">            nums[m] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = nums[m];</span><br><span class="line">    nums[m] = t;</span><br><span class="line">    QuickSort(nums, left, m-<span class="number">1</span>);</span><br><span class="line">    QuickSort(nums,m+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>考虑一种极端的情况：n个相同元素组成的数组。对于这种输入，插入排序的性能非常好：每个元素需要移动的距离都为0，所以总运行时间为O(n)。但QuickSort函数的性能却非常差。n-1次划分中每次都需要O(n)时间来去掉一个元素，所以总运行时间为O(n^2)。于是，考虑使用双向划分可以避免这个问题：<br>使用下标i和j表示初始化时待划分数组的两端索引。主循环中有两个内循环，第一个内循环将i向右移过小元素，遇到大元素停止；第二个内循环将j向左移过大元素，遇到小元素停止。然后主循环测试这两个下标是否交叉并交换它们的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BetterQuickSort</span><span class="params">(Integer[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = nums[left];</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(++i &lt;= right &amp;&amp; nums[i] &lt; t);</span><br><span class="line">        <span class="keyword">while</span>(nums[--j] &gt; t);</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(nums[i],nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[left],nums[j]);</span><br><span class="line">    BetterQuickSort(nums, left, j-<span class="number">1</span>);</span><br><span class="line">    BetterQuickSort(nums, j+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：</p><ul><li>快速排序是不稳定的排序。</li><li>快速排序的时间复杂度为O(nlogn)。</li><li>当n较大时使用快排比较好，当序列基本有序时用快排反而不好。</li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>基本思想:归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(Integer[] nums,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">    MergeSort(nums, left, mid);</span><br><span class="line">    MergeSort(nums,mid+<span class="number">1</span>, right);</span><br><span class="line">    Merge(nums, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(Integer[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    Integer[] temp = <span class="keyword">new</span>  Integer[nums.length];</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid+<span class="number">1</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[j])</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right)&#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = left; i &lt;= right; i++)</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：</p><ul><li>归并排序是稳定的排序方法。</li><li>归并排序的时间复杂度为O(nlogn)。</li><li>速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>排序算法</th><th>平均时间</th><th>最好时间</th><th>最坏时间</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>二分插入</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>直接选择</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(nlogn)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>稳定</td></tr></tbody></table><ul><li>当排序记录个数n较大，关键码分布较随机，且对稳定性不作要求时，采用快速排序为宜。 </li><li>当待排序记录个数n较大，内存空间允许，且要求稳定排序时，采用归并排序。 </li><li>当待排序记录个数n较大，关键码分布可能出现正序或逆序的情况，且对稳定性不作要求时，采用堆排序或归并排序。 </li><li>当待排序记录个数n较大，而只要找出最小的前几个记录，采用堆排序或简单选择排序。 </li><li>当待排序记录个数n较小（如小于100）时，记录已基本有序，且要求稳定时，采用直接插入排序。 </li><li>当待排序记录个数n较小，记录所含数据项较多，所占存储空间较大时，采用简单选择排序。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;直接插入排序&quot;&gt;&lt;a href=&quot;#直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序&quot;&gt;&lt;/a&gt;直接插入排序&lt;/h3&gt;&lt;p&gt;算法实现过程：筛选过程通过一个从右到左的循环实现，该循环使用变量j跟踪被筛选的元素。只要该元素具有前驱（j&amp;gt;0）且没有达到最终位置，循环就交换该元素和它的前驱，代码实现如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InsertSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Integer[] a)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; a.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = i; j &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; a[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&amp;gt;a[j]; j--)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            a[j] = a[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            a[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;算法分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定待排序的数列初态不同时，直接插入排序所耗费的时间有很大差异。&lt;/li&gt;
&lt;li&gt;若初态为正序，则每个待插入的记录只需比较一次就能找到对应位置插入，此时算法的时间复杂度为O(n)。&lt;/li&gt;
&lt;li&gt;若初态为反序，则第i个待插入记录需要比较i+1次才能找到合适位置插入，此时时间复杂度为O(n^2)。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://thecoy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JS异步设计</title>
    <link href="http://thecoy.github.io/2017/08/27/JS%E5%BC%82%E6%AD%A5%E8%AE%BE%E8%AE%A1/"/>
    <id>http://thecoy.github.io/2017/08/27/JS异步设计/</id>
    <published>2017-08-27T03:55:16.000Z</published>
    <updated>2018-11-12T14:50:26.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-异步任务设计"><a href="#JavaScript-异步任务设计" class="headerlink" title="JavaScript 异步任务设计"></a>JavaScript 异步任务设计</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asyncFunA()</span></span><br><span class="line"><span class="comment">// asyncFunB()</span></span><br><span class="line"><span class="comment">// asyncFunC()</span></span><br><span class="line">RunTasks(&#123;</span><br><span class="line">    duration:<span class="number">1000</span>,</span><br><span class="line">    tasks:[</span><br><span class="line">        [asyncFunA, <span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">        asyncFunB,</span><br><span class="line">        [asyncFunC,<span class="string">'baz'</span>]</span><br><span class="line">    ],</span><br><span class="line">    done:<span class="function"><span class="keyword">function</span> (<span class="params">resultA, resultB, resultC</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(resultA, resultB, resultC);</span><br><span class="line">    &#125;,</span><br><span class="line">    fail:<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;,</span><br><span class="line">    timeout:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>要求设计一个RunTask函数，使得三个异步任务在给定时间内执行完后输出对应结果，如果超时则打印超时提示，如果失败则提示任务异常信息：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncFunA = <span class="function"><span class="keyword">function</span> (<span class="params">param1, param2, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'asyncFunctionA running'</span>);</span><br><span class="line">    callback &amp;&amp; callback();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> asyncFunB = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'asyncFunctionB running'</span>);</span><br><span class="line">    callback &amp;&amp; callback();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> asyncFunC = <span class="function"><span class="keyword">function</span> (<span class="params">param1,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> otime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'asyncFunctionC running'</span>);</span><br><span class="line">    <span class="keyword">var</span> ntime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">while</span>(ntime-otime &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">        ntime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"time:"</span> + <span class="built_in">Date</span>(ntime-otime));</span><br><span class="line">    &#125;</span><br><span class="line">    callback &amp;&amp; callback();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">RunTasks</span>(<span class="params">runTasks</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> length  =runTasks.tasks.length;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> timer1 = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        timeout = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'-----start-----'</span>);</span><br><span class="line">        <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            timeout = <span class="literal">true</span>;</span><br><span class="line">            callback &amp;&amp; callback();</span><br><span class="line">        &#125;,runTasks.durartion);</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timer = timer1(runTasks.timeout);</span><br><span class="line"></span><br><span class="line">    runTasks.tasks.forEach( <span class="function"><span class="keyword">function</span> (<span class="params">funitem, index </span>)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> fun = funitem;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(funitem)) &#123;</span><br><span class="line">                fun = funitem[<span class="number">0</span>];</span><br><span class="line">                funitem = funitem.slice(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//fun = funitem.splice(0,1);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                funitem = [];</span><br><span class="line">            &#125;</span><br><span class="line">            funitem.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                res[index] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;length;i++ ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!res[i])</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">                timeout || runTasks.done(res);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                fun.apply(<span class="keyword">this</span>, funitem);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">            runTasks.fail(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript-异步任务设计&quot;&gt;&lt;a href=&quot;#JavaScript-异步任务设计&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 异步任务设计&quot;&gt;&lt;/a&gt;JavaScript 异步任务设计&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// asyncFunA()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// asyncFunB()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// asyncFunC()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RunTasks(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    duration:&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tasks:[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [asyncFunA, &lt;span class=&quot;string&quot;&gt;&#39;foo&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        asyncFunB,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [asyncFunC,&lt;span class=&quot;string&quot;&gt;&#39;baz&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    done:&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;resultA, resultB, resultC&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(resultA, resultB, resultC);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fail:&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.error(err);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    timeout:&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;timeout&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="异步" scheme="http://thecoy.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Choose Life</title>
    <link href="http://thecoy.github.io/2017/06/27/Choose-Life/"/>
    <id>http://thecoy.github.io/2017/06/27/Choose-Life/</id>
    <published>2017-06-27T13:43:37.000Z</published>
    <updated>2018-11-12T14:50:26.499Z</updated>
    
    <content type="html"><![CDATA[<p>Choose your future, Veronika. Choose life.</p><p>看完《猜火车2》之后，又倒回去看了几遍Mark对Veronika解释什么是“Choose Life”，电影剧情于我并没有什么特别大的感触，尽管对剧中部分台词的过分沉迷让我甚至对于导演想要表达的东西在正确理解的道路上越走越远，可我还是忍不住想要写下点抑或记录点什么自己的感想…<br><a id="more"></a><br>人们总是喜欢说，人生充满了选择。诚然，人生就是由无数个选择所构成的。</p><p>选择埋头苦读，于是还要选择挤过高考的独木桥</p><p>选择默不作声，于是还要选择独自扛下所有不平等公正的遭遇</p><p>选择独自前行，于是还要选择拥有并享受孤独</p><p><img src="/assets/blogImg/p1706271.jpg" alt="image"></p><p>20年前，雷顿在开场中愤世嫉俗地说道，“选择生活，选择工作，选择事业，选择家庭，选他妈的大电视，选洗衣机、车子、CD、电动开罐器，选择健康、低胆固醇和牙医保险、定息低率贷款，选择房子，选择朋友，选择休闲服跟搭配的行李箱，选择各种布料的西装，选DIY，怀疑自己是什么？看心智麻痹的电视，嘴里塞满垃圾食物，最后整个人腐烂到底，在悲惨的家里生一堆自私的混蛋小孩烦死自己，不过是难堪罢了，选择未来，选择生活，…我干嘛做这些事？”</p><p><img src="/assets/blogImg/p1706272.jpg" alt="image"></p><p>20年后，雷顿在海报里这样写道，“选择生活，选择facebook、twitter、Instagram并且希望有人在乎。选择看着你的旧情人，希望你能改变当时做错的事情。选择看着历史自我重复。选择你的未来，选择电视真人秀，荡妇羞辱，色情报复。选择零工时的合约，和一段两小时的上班路程。并且帮你的小孩做一模一样的选择，一个只会更糟，就像是你在某人厨房打了一剂不知名毒品后感到窒息般痛苦的选择，然后深呼吸。”<br>你始终是个瘾君子，那么就去上瘾吧！去找些别的什么，让你真正上瘾的事情。</p><blockquote><p>Choose unfulfilled promise and wishing you’d done it all differently.<br>选择不履行承诺，之后又希望自己从头来过</p></blockquote><blockquote><p>Choose never learning from your own mistakes. Choose watching history repeat itself.<br>选择从不吸取自己错误的教训 选择看着历史一遍遍重演</p></blockquote><blockquote><p>Choose the slow reconciliation towards what you can get, rather than what you always hoped for. Settle for less and keep a brave face on it.<br>选择慢慢屈就于你能得到的，而不是你一直都想要的。见好就收 但面子上还要硬撑</p></blockquote><blockquote><p>Choose disappointment and choose losing the ones you love, then as they fall from view, a piece of you dies with them until you can see that one day in the future, piece by piece, they will all be gone and there’ll be nothing left of you to call alive or dead.<br>选择失望 选择痛失所爱，随她们渐行渐远，你的一部分也与她们一并消逝 你知道将来的某一天，一点又一点，它们都消逝无踪 那时你的自我一点不剩 生死难明</p></blockquote><blockquote><p>Choose your future, Veronika. Choose life.<br>选择你的未来，Veronika，选择人生</p></blockquote><p>无论是选择，还是被选择，决定权其实最终还是在自己的手里！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Choose your future, Veronika. Choose life.&lt;/p&gt;
&lt;p&gt;看完《猜火车2》之后，又倒回去看了几遍Mark对Veronika解释什么是“Choose Life”，电影剧情于我并没有什么特别大的感触，尽管对剧中部分台词的过分沉迷让我甚至对于导演想要表达的东西在正确理解的道路上越走越远，可我还是忍不住想要写下点抑或记录点什么自己的感想…&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://thecoy.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Lambda之初体验</title>
    <link href="http://thecoy.github.io/2017/06/25/Lambda%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://thecoy.github.io/2017/06/25/Lambda之初体验/</id>
    <published>2017-06-25T09:26:19.000Z</published>
    <updated>2018-11-12T14:50:26.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式之初体验"><a href="#Lambda表达式之初体验" class="headerlink" title="Lambda表达式之初体验"></a>Lambda表达式之初体验</h2><p>最近在重新系统地学习Python这门语言，在学习关于数据结构中的列表构造部分时，里面也有提到Lambda表达式，不过只是浅尝辄止罢了，加上之前Java（8以上的版本才支持）里面也有用到过Lambda这个东西，索性单独学习并记录之。<br><a id="more"></a></p><h3 id="Lambda表达式的定义"><a href="#Lambda表达式的定义" class="headerlink" title="Lambda表达式的定义"></a>Lambda表达式的定义</h3><p>Lambda 表达式是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。</p><h3 id="Lambda表达的不完全列举用法"><a href="#Lambda表达的不完全列举用法" class="headerlink" title="Lambda表达的不完全列举用法"></a>Lambda表达的不完全列举用法</h3><p>1.使用Lambda表达式作为函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x:x**<span class="number">2</span></span><br><span class="line">x = f(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><ul><li>一个返回某个集合的所有子集的 lambda 函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x:[[y <span class="keyword">for</span> j, y <span class="keyword">in</span> enumerate(set(x)) <span class="keyword">if</span>(i &gt;&gt; j) &amp; <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>**len(set(x)))]</span><br></pre></td></tr></table></figure></li></ul><p>2.使用Lambda表达式作为参数传递：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pairs = [(<span class="number">1</span>, <span class="string">'one'</span>), (<span class="number">2</span>, <span class="string">'two'</span>), (<span class="number">3</span>, <span class="string">'three'</span>), (<span class="number">4</span>, <span class="string">'four'</span>)]</span><br><span class="line">pairs.sort(key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p>3.使用Lambda表达式构造列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = list(map(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,range(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure></p><ul><li>map() 函数，它可以将一个函数映射到一个可枚举类型上面。于是map(f,a)就意味着将函数f依次作用在a的每一个元素上。</li></ul><p>4.使用Lambda函数作为闭包：</p><blockquote><p>闭包就是一个定义在函数内部的函数，闭包使得变量即使脱离了该函数的作用域范围也依然能被访问到。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x+n</span><br><span class="line">f = foo(<span class="number">0</span>)</span><br><span class="line">print(f(<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="下面是对比在Python中使用嵌套结构和Lambda两种方式构造列表的比较："><a href="#下面是对比在Python中使用嵌套结构和Lambda两种方式构造列表的比较：" class="headerlink" title="下面是对比在Python中使用嵌套结构和Lambda两种方式构造列表的比较："></a>下面是对比在Python中使用嵌套结构和Lambda两种方式构造列表的比较：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">            [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],</span><br><span class="line">                [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#嵌套结构的列表推导式</span></span><br><span class="line">res = [[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]))]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Lambda表达式构造外层列表，列表推导式构造里层列表</span></span><br><span class="line">res = list(map(<span class="keyword">lambda</span> x:[row[x] <span class="keyword">for</span> row <span class="keyword">in</span> matrix],range(len(matrix[<span class="number">0</span>]))))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Lambda表达式构造里层列表，列表推导式构造外层列表-1</span></span><br><span class="line">res = [list(map(<span class="keyword">lambda</span> row:row[x],matrix)) <span class="keyword">for</span> x <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]))]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Lambda表达式构造里层列表，列表推导式构造外层列表-2</span></span><br><span class="line">res = [list(map(<span class="keyword">lambda</span> row:row[x],[row <span class="keyword">for</span> row <span class="keyword">in</span> matrix])) <span class="keyword">for</span> x <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#双Lambda方式构造列表-1</span></span><br><span class="line">res = list(map(<span class="keyword">lambda</span> x:list(map(<span class="keyword">lambda</span> row:row[x],matrix)),range(len(matrix[<span class="number">0</span>]))))</span><br><span class="line"></span><br><span class="line"><span class="comment">#双Lambda方式构造列表-2</span></span><br><span class="line">res = list(map(<span class="keyword">lambda</span> x:list(map(<span class="keyword">lambda</span> row:row[x],[row <span class="keyword">for</span> row <span class="keyword">in</span> matrix])),range(len(matrix[<span class="number">0</span>]))))</span><br></pre></td></tr></table></figure><p><strong>未完待续ing….</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Lambda表达式之初体验&quot;&gt;&lt;a href=&quot;#Lambda表达式之初体验&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式之初体验&quot;&gt;&lt;/a&gt;Lambda表达式之初体验&lt;/h2&gt;&lt;p&gt;最近在重新系统地学习Python这门语言，在学习关于数据结构中的列表构造部分时，里面也有提到Lambda表达式，不过只是浅尝辄止罢了，加上之前Java（8以上的版本才支持）里面也有用到过Lambda这个东西，索性单独学习并记录之。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://thecoy.github.io/tags/Java/"/>
    
      <category term="Python" scheme="http://thecoy.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Sumo仿真</title>
    <link href="http://thecoy.github.io/2017/06/24/Sumo%E4%BB%BF%E7%9C%9F/"/>
    <id>http://thecoy.github.io/2017/06/24/Sumo仿真/</id>
    <published>2017-06-24T15:25:45.000Z</published>
    <updated>2018-11-12T14:50:26.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SUMO-仿真学习笔记"><a href="#SUMO-仿真学习笔记" class="headerlink" title="SUMO 仿真学习笔记"></a>SUMO 仿真学习笔记</h1><h2 id="仿真方案的一般步骤"><a href="#仿真方案的一般步骤" class="headerlink" title="仿真方案的一般步骤"></a>仿真方案的一般步骤</h2><p>1.创建网络</p><ul><li>使用Netgen生成抽象网络</li><li>通过xml文件自定义配置网络，然后用Netconvert 导入</li><li>使用Netconvert导入已存在的网络（OSM地图）</li></ul><a id="more"></a><p>2.需求建模</p><ul><li>描述明确的车辆路径</li><li>仅使用车流和转弯概率</li><li>生成随机路径</li><li>导入OD矩阵格式</li><li>导入已存在路径</li></ul><p>3.计算动态用户分配<br>4.校正仿真<br>5.执行仿真</p><h3 id="1-SUMO道路网络的构建"><a href="#1-SUMO道路网络的构建" class="headerlink" title="1. SUMO道路网络的构建"></a>1. SUMO道路网络的构建</h3><p><strong>网络格式</strong></p><ul><li>Sumo 道路网络是个有向图</li><li>节点代表道路交叉口</li><li>边代表道路或街道</li></ul><p><strong>边和车道</strong></p><ul><li>ID：边的标识</li><li>From：起始节点的ID</li><li>To：终止节点的ID</li><li>Priority：道路的优先级</li><li>Function:抽象边的用途（目的）<ul><li>normal:普通边，如高速公路或链接两条道路的街道</li><li>connector:微观连接器，并不是真实世界道路网络的一部分</li><li>internal:这类“边”是交叉口的一部分（在交叉口内部）</li></ul></li></ul><p><strong>1.1 使用XML文件构建自定义道路网络</strong></p><ul><li>节点的描述<br>节点文件一般以”.nod.xml”作为扩展名，每行描述一个节点，如下所示：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">id</span>=<span class="string">"&lt;STRING&gt;"</span> <span class="attr">x</span>=<span class="string">"&lt;FLOAT&gt;"</span> <span class="attr">y</span>=<span class="string">"&lt;FLOAT&gt;"</span> [<span class="attr">type</span>=<span class="string">"&lt;TYPE&gt;"</span>]/&gt;</span></span><br></pre></td></tr></table></figure><p>Type为可选字段，代表节点的类型，其取值及含义如下所示:</p><table><thead><tr><th>Type</th><th>对应含义</th></tr></thead><tbody><tr><td>priority</td><td>车辆必须等待，直到它们右侧车辆完全通过路口</td></tr><tr><td>traffic_light</td><td>交叉口被交通灯控制</td></tr><tr><td>right_before_left</td><td>来自右边的车辆优先通过</td></tr></tbody></table><p>一个节点描述示例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">x</span>=<span class="string">"-500.0"</span> <span class="attr">y</span>=<span class="string">"0.0"</span> <span class="attr">type</span>=<span class="string">"priority"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>边的描述<br>边和节点的描述差不多，但还有其他参数。边的描述格式如下所示：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">edge</span> <span class="attr">id</span>=<span class="string">"&lt;STRING&gt;"</span> (<span class="attr">fromnode</span>=<span class="string">"&lt;NODE_ID&gt;"</span> <span class="attr">tonode</span>=<span class="string">"&lt;NODE_ID&gt;"</span> | <span class="attr">xfrom</span>=<span class="string">"&lt;FLOAT&gt;"</span> <span class="attr">yfrom</span>=<span class="string">"&lt;FLOAT&gt;"</span> <span class="attr">xto</span>=<span class="string">"&lt;FLOAT&gt;"</span> <span class="attr">yto</span>=<span class="string">"&lt;FLOAT&gt;"</span>)  [<span class="attr">type</span>=<span class="string">"&lt;STRING&gt;"</span> | <span class="attr">nolanes</span>=<span class="string">"&lt;INT&gt;"</span> <span class="attr">speed</span>=<span class="string">"&lt;FLOAT&gt;"</span> <span class="attr">priority</span>=<span class="string">"&lt;UINT&gt;"</span> <span class="attr">length</span>=<span class="string">"&lt;FLOAT&gt;"</span>)][<span class="attr">shape</span>=<span class="string">"&lt;2D_POINT&gt; [ &lt;2D_POINT&gt;]*"</span>] [<span class="attr">spread_type</span>=<span class="string">"center"</span>]/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>每个边都是单向的：从起始节点开始，在终 止节点结束。如果所给出的节点名字不能提取(因为在节点文件中没有定义)，将会产生错误。</p><p>对每条边，应提供更多的属性，如拥有的车道数，允许的最大车速，边的长度(米)。而 且，还可以定义优先级(可选)。所有这些值（除了长度），可以使用相关的属性值给出，或 者给边一个类型以省略它们。</p><p>边的属性如下：</p><table><thead><tr><th>属性名</th><th>值类型</th><th>描述</th></tr></thead><tbody><tr><td>ID</td><td>string</td><td>边的名字</td></tr><tr><td>fromnode</td><td>参考node_id</td><td>边的起始节点，需在节点文件中存在</td></tr><tr><td>tonode</td><td>参考node_id</td><td>边的终止节点，需在节点文件中存在</td></tr><tr><td>type</td><td>参考type_id</td><td>类型名</td></tr><tr><td>nolanes</td><td>int</td><td>边的车道数，必须是整数</td></tr><tr><td>speed</td><td>float</td><td>边允许的最大车速(m/s)，必须是浮点数</td></tr><tr><td>priority</td><td>int</td><td>边的优先权</td></tr><tr><td>length</td><td>float</td><td>边长(m)</td></tr><tr><td>shape</td><td>位置列表，用(x1,y1,x2,y2)表示，单位m</td><td>例如：<code>&lt;edge id=&quot;e1&quot; fromnode=&quot;0&quot; tonode=&quot;1&quot; shape=&quot;0,0 0,100&quot;/&gt;</code> 描述一个边， 从节点0开始，首先经过点(0,0)，然后向右行 100米，最后到达节点1</td></tr><tr><td>spread_type</td><td>枚举类型（right,center）</td><td>描述怎样延展车道，center表示双向延展车道， 其他值为右向延展 </td></tr></tbody></table><p>一条边的描述示例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">edge</span> <span class="attr">id</span>=<span class="string">"2o"</span> <span class="attr">fromnode</span>=<span class="string">"0"</span> <span class="attr">tonode</span>=<span class="string">"2"</span> <span class="attr">priority</span>=<span class="string">"1"</span> <span class="attr">nolanes</span>=<span class="string">"1"</span> <span class="attr">speed</span>=<span class="string">"11.11"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>使用Netconvert构建网络调用格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netconvert --xml-node-files=MyNodes.nod.xml --xml-edge-files=MyEdges.edg.xml --output-file=MySUMONet.net.xml</span><br></pre></td></tr></table></figure></li></ul><p>如果还使用了类型和连接文件，则调用格式如下：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netconvert --xml-node-files=MyNodes.nod.xml --xml-edge-files=MyEdges.edg.xml --xml-connection-files=MyConnections.<span class="built_in">con</span>.xml --xml-<span class="built_in">type</span>-files=MyTypes.typ.xml --output-file=MySUMONet.<span class="built_in">net</span>.xml</span><br></pre></td></tr></table></figure></p><p>可能你的边的定义不完整或有错，如果你仍希望导入这个网络，可以试着使用 NETCONVERT的–dismiss-loading-errors参数忽略这些。这样，定义不正确的边将被省略， 但是NETCONVERT仍试图构建网络。</p><p><strong>1.2 OpenStreetMap格式的路网导入</strong></p><p>从OpenStreetMap的<a href="http://www.openstreetmap.org/" target="_blank" rel="noopener">官方网站</a>可以知道， OpenStreetMap是一个可自由编辑的世界地图，它由来自全世界的人士共同编辑维护。 OpenStreetMap工程的地图数据文件是一个或多个XML文件。 注意：OSM数据可以有多种不同的方式下载获得。</p><p>NETCONVERT可以导入本地的OSM数据文件，这需要使用选项—osm-files \<file> 下面的命令导入OSM格式路网文件berlin.osm.xml，并把产生的SUMO路网文件保存为 berlin.net.xml：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netconvert --osm-files berlin.osm.xml -o berlin.<span class="built_in">net</span>.xml</span><br></pre></td></tr></table></figure></file></p><p>注意：导入OSM路网后，一个路口节点可能被分为很多歌节点，这样既不美观，也影响 仿真效果，我们可以合并距离较近的节点，或者指定合并哪些节点，具体如下：<br> <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netconvert --osm-files map.osm --junctions.join-dist <span class="number">50</span> -o guiyang.<span class="built_in">net</span>.xml</span><br></pre></td></tr></table></figure></p><hr><h3 id="2-需求建模"><a href="#2-需求建模" class="headerlink" title="2. 需求建模"></a>2. 需求建模</h3><p> 在产生路网之后，我们通过GUISIM可以发现，并没有车辆运行。我们还需要对车辆进行一些描述，于是有了如下关于旅程和路径的定义：</p><ul><li>旅程(trip) —— 旅程是车辆从一地到另一地的移动，由起始边，目的边和所用时间的定义 </li><li>路径(route) —— 路径是扩展的旅程，这就是说路径的定义不仅包含起止边，还包括车俩将 通过的所有的边。SUMO和GUISIM需要路径作为车辆移动的输入数据。有多种方法可以为 SUMO生产路径信息</li></ul><p>Sumo中用于处理路径信息的工具：</p><ol><li>Duarouter —— 负责从其他仿真软件包导入路径或定义，并使用Dijkstra的最短路径算 法计算路径。另外与仿真相结合，DUAROUTER程序可以计算动态用户分配(C. Gawron的模 型)</li><li>Jtrrouter —— 使用交叉口的转弯率来静态的建模交通</li><li>Od2trips —— 用于转换OD矩阵到旅程信息</li><li>Dfrouter —— 从所给的观察点的度量计算路径</li></ol><p><strong>可行的生成随机路径的方法</strong><br>1.使用sumo\tools\trip目录下的randomTrips.py脚本生成*.trip.xml随机旅程文件(net 文件作为输入)<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomTrips.py  –n  beijing.<span class="built_in">net</span>.xml</span><br></pre></td></tr></table></figure></p><p>2.使用Duarouter工具(使用net文件和trip文件作为输入)生成路径文件<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duarouter  –n test.<span class="built_in">net</span>.xml  –t test.trip.xml  –o test.rou.xml --continue-on-unbuild(忽略错误继续) –w(不显示警告信息)</span><br></pre></td></tr></table></figure></p><hr><h3 id="3-可行的仿真方案"><a href="#3-可行的仿真方案" class="headerlink" title="3. 可行的仿真方案"></a>3. 可行的仿真方案</h3><p><strong>3.1  使用随机路径仿真</strong><br>1.在OpenStreetMap网站下载osm格式的城市地图<br>2.使用netconvert把osm格式地图转换为SUMO格式的路网:<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netconvert --osm-files berlin.osm.xml -o berlin.<span class="built_in">net</span>.xml</span><br></pre></td></tr></table></figure></p><p>3.使用sumo\tools\trip目录下的randomTrips.py脚本生成*.trip.xml随机旅程文件(net 文件作为输入)，以下命令生成berlin.trip.xml随机旅程文件:<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomTrips.py  –n  berlin.<span class="built_in">net</span>.xml</span><br></pre></td></tr></table></figure></p><p>4.使用Duarouter工具(使用net文件和trip文件作为输入)生成路径文件(也可使用车 辆定义文件)<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duarouter  –n berlin.<span class="built_in">net</span>.xml  –t berlin.trip.xml  –o berlin.rou.xml --continue-on-unbuild(忽略错误继续) –w(不显示警告信息)</span><br></pre></td></tr></table></figure></p><p>5.手工编辑berlin.sumo.cfg配置文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">net-file</span> <span class="attr">value</span>=<span class="string">"berlin.net.xml"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">route-files</span> <span class="attr">value</span>=<span class="string">"berlin.rou.xml"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--产生的polygon文件berlin.poly.xml需要添加进sumo-gui配置里面： --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">additional-files</span> <span class="attr">value</span>=<span class="string">"berlin.poly.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">output</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">vehroute-output</span> <span class="attr">value</span>=<span class="string">"vehroutes.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">output</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">report</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">no-duration-log</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span> <span class="tag">&lt;<span class="name">no-step-log</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">report</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>6.在可视化仿真工具sumo-gui中打开berlin.sumo.cfg配置文件，点击运行仿真按钮即可开始仿真</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SUMO-仿真学习笔记&quot;&gt;&lt;a href=&quot;#SUMO-仿真学习笔记&quot; class=&quot;headerlink&quot; title=&quot;SUMO 仿真学习笔记&quot;&gt;&lt;/a&gt;SUMO 仿真学习笔记&lt;/h1&gt;&lt;h2 id=&quot;仿真方案的一般步骤&quot;&gt;&lt;a href=&quot;#仿真方案的一般步骤&quot; class=&quot;headerlink&quot; title=&quot;仿真方案的一般步骤&quot;&gt;&lt;/a&gt;仿真方案的一般步骤&lt;/h2&gt;&lt;p&gt;1.创建网络&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Netgen生成抽象网络&lt;/li&gt;
&lt;li&gt;通过xml文件自定义配置网络，然后用Netconvert 导入&lt;/li&gt;
&lt;li&gt;使用Netconvert导入已存在的网络（OSM地图）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="SUMO" scheme="http://thecoy.github.io/tags/SUMO/"/>
    
  </entry>
  
  <entry>
    <title>Java foreach循环遍历操作</title>
    <link href="http://thecoy.github.io/2017/05/31/Java-foreach%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C/"/>
    <id>http://thecoy.github.io/2017/05/31/Java-foreach循环遍历操作/</id>
    <published>2017-05-31T12:22:12.000Z</published>
    <updated>2018-11-12T14:50:26.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先贴一段会报异常的代码"><a href="#先贴一段会报异常的代码" class="headerlink" title="先贴一段会报异常的代码"></a>先贴一段会报异常的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"first"</span>);</span><br><span class="line">        list.add(<span class="string">"second"</span>);</span><br><span class="line">        list.add(<span class="string">"third"</span>);</span><br><span class="line">        list.add(<span class="string">"fourth"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"first"</span>.equals(str))</span><br><span class="line">                list.remove(str);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上代码会报java.util.ConcurrentModificationException这个异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure></p><a id="more"></a><p> for(String str:list)　这句话实际上是用到了集合的iterator() 方法,一般我们也会经常用到iterator来遍历集合，但是一旦设计到对元素进行修改（CRUD）的时候就需要格外注意了，具体一看源码便知：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--java.util. AbstractList的内部类Itr的源码--&gt;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)  </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();  </span><br><span class="line">           checkForComodification();  </span><br><span class="line"> </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           AbstractList.<span class="keyword">this</span>.remove(lastRet); <span class="comment">//执行remove的操作  </span></span><br><span class="line">           <span class="keyword">if</span> (lastRet &lt; cursor)  </span><br><span class="line">             cursor--;  </span><br><span class="line">           lastRet = -<span class="number">1</span>;  </span><br><span class="line">           expectedModCount = modCount; <span class="comment">//保证了modCount和expectedModCount的值的一致性，避免抛出ConcurrentModificationException异常  </span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123; </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (modCount != expectedModCount) <span class="comment">//当modCount和expectedModCount值不相等时，则抛出ConcurrentModificationException异常  </span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 然而，ArrayList的remove方法是这样的：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </span><br><span class="line">        <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            fastRemove(index);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </span><br><span class="line">        <span class="keyword">if</span> (o.equals(elementData[index])) &#123;  </span><br><span class="line">            fastRemove(index);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not </span></span><br><span class="line"><span class="comment">     * return the value removed. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        modCount++; <span class="comment">//只是修改了modCount，因此modCount将与expectedModCount的值不一致  </span></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </span><br><span class="line">            System.arraycopy(elementData,index+<span class="number">1</span>,elementData,index,numMoved);  </span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work  </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>通过阅读源码即可知道，ArrayList的remove方法只是修改了modCount的值，并没有修改expectedModCount，导致modCount和expectedModCount的值的不一致性，当next()时则抛出ConcurrentModificationException异常。因此使用Iterator遍历集合时，不要改动被迭代的对象，可以使用 Iterator 本身的方法 remove() 来删除对象，Iterator.remove()方法会在删除当前迭代对象的同时维护modCount和expectedModCount值的一致性。</li></ul><ul><li>另外注意如果是如下的情况又不会报异常：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"first"</span>);</span><br><span class="line">        list.add(<span class="string">"second"</span>);</span><br><span class="line">        list.add(<span class="string">"third"</span>);</span><br><span class="line">        list.add(<span class="string">"fourth"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String str: list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"third"</span>.equals(str))</span><br><span class="line">                list.remove(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>这是因为在删除倒数第二个元素的时候，cursor指向最后一个元素的，而此时删掉了倒数第二个元素后，cursor和size()正好相等了，所以hasNext()返回false，遍历结束，于是也就不会进入到next（）执行checkForComodification检查了，所以也就不会报异常。</li><li><p>最后，回到本文的主题，foreach（）循环遍历的正确打开方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"first"</span>);</span><br><span class="line">        list.add(<span class="string">"second"</span>);</span><br><span class="line">        list.add(<span class="string">"third"</span>);</span><br><span class="line">        list.add(<span class="string">"fourth"</span>);</span><br><span class="line">        list.add(<span class="string">"five"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String temp = it.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"five"</span>.equals(temp))</span><br><span class="line">                it.remove();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>不过对于在多线程环境下对集合类元素进行迭代修改操作，最好把代码放在一个同步代码块内，这样才能保证modCount和expectedModCount的值的一致性，类似如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();    </span><br><span class="line"><span class="keyword">synchronized</span>(synObject) &#123;  </span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext()) &#123;    </span><br><span class="line">        String str = iterator.next();    </span><br><span class="line">        <span class="keyword">if</span>(del.contains(str)) &#123;    </span><br><span class="line">            iterator.remove();    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先贴一段会报异常的代码&quot;&gt;&lt;a href=&quot;#先贴一段会报异常的代码&quot; class=&quot;headerlink&quot; title=&quot;先贴一段会报异常的代码&quot;&gt;&lt;/a&gt;先贴一段会报异常的代码&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;String&amp;gt; list = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;string&quot;&gt;&quot;first&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;string&quot;&gt;&quot;second&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;string&quot;&gt;&quot;third&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;string&quot;&gt;&quot;fourth&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(String str:list)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;first&quot;&lt;/span&gt;.equals(str))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                list.remove(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(list.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如上代码会报java.util.ConcurrentModificationException这个异常：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Exception in thread &amp;quot;main&amp;quot; java.util.ConcurrentModificationException&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://thecoy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java装拆箱</title>
    <link href="http://thecoy.github.io/2017/05/24/Java%E8%A3%85%E6%8B%86%E7%AE%B1/"/>
    <id>http://thecoy.github.io/2017/05/24/Java装拆箱/</id>
    <published>2017-05-24T12:47:33.000Z</published>
    <updated>2018-11-12T14:50:26.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于Java装拆箱与包装类型的学习"><a href="#关于Java装拆箱与包装类型的学习" class="headerlink" title="关于Java装拆箱与包装类型的学习"></a>关于Java装拆箱与包装类型的学习</h2><h3 id="Java的包装类"><a href="#Java的包装类" class="headerlink" title="Java的包装类"></a>Java的包装类</h3><blockquote><p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)，有些地方也翻译为外覆类或数据类型类，如下表所示：</p></blockquote><a id="more"></a><table><thead><tr><th>基本数据类型</th><th>对应的包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h4 id="Java-包装器类的主要目的"><a href="#Java-包装器类的主要目的" class="headerlink" title="Java 包装器类的主要目的"></a>Java 包装器类的主要目的</h4><ul><li>提供一种机制，将基本值“包装”到对象中，从而使基本值能够包含在为对象而保留的操作中，比如添加到Collections 中，或者从带对象返回值的方法中返回。</li><li>为基本值提供分类功能。这些功能大多数于各种转换有关：在基本值和String对象间相互转换，在基本值和String对象之间按不同基数转换，如二进制、八进制和十六进制。</li></ul><hr><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>在Java SE5之前，如果要生成一个数值为100的Integer对象，必须这样进行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p><p>而从Java SE5开始提供了自动装箱的特性，上述代码可写成如下形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></p><p>那么在这个过程中会自动根据数值创建对应的Integer对象，这就是<strong><em>装箱</em></strong>，自动调用Integer的valueOf()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer test = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> f = test.initValue();</span><br></pre></td></tr></table></figure></p><p>而以上则就是所谓的<strong><em>拆箱</em></strong>，自动调用Integer的intValue（）方法。于是，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装箱--&gt;自动将基本数据类型转换为包装器类型</span><br><span class="line">拆箱--&gt;自动将包装器类型转换为基本数据类型</span><br></pre></td></tr></table></figure><hr><h3 id="与之相关的坑与警示"><a href="#与之相关的坑与警示" class="headerlink" title="与之相关的坑与警示"></a>与之相关的坑与警示</h3><ul><li>由于最近在看《阿里巴巴JAVA开发手册》，在（4）OOP规约的第7条中提到，<blockquote><ol start="7"><li>【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 </li></ol></blockquote></li></ul><p>究竟是什么原因让阿里的程序猿们如此深恶痛觉，其实只需一看源码便知晓答案了，下面这段代码是Integer的valueOf方法的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntergerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>说明：对于 Integer var=?在-128 至 127 之间的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行 判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑， 推荐使用 equals 方法进行判断</li></ul><hr><h3 id="一些关于装箱与拆箱的面试题"><a href="#一些关于装箱与拆箱的面试题" class="headerlink" title="一些关于装箱与拆箱的面试题"></a>一些关于装箱与拆箱的面试题</h3><ul><li>这里，先通过下面的表格弄清楚“==”和equals()的区别.</li></ul><table><thead><tr><th>基本数据类型</th><th>==</th><th>equals()</th></tr></thead><tbody><tr><td>字符串变量</td><td>对象内存地址</td><td>字符串内容</td></tr><tr><td>非字符串变量</td><td>对象内存地址</td><td>对象内存地址</td></tr><tr><td>基本类型</td><td>值</td><td>不可用</td></tr><tr><td>包装类</td><td>对象内存地址</td><td>内容</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        Integer i3 = <span class="number">200</span>;</span><br><span class="line">        Integer i4 = <span class="number">200</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出结果：</span></span><br><span class="line"><span class="comment">* true</span></span><br><span class="line"><span class="comment">* false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>参照以上Integer的valueOf()方法的源码不难理解上述的输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double i1 = <span class="number">100.0</span>;</span><br><span class="line">        Double i2 = <span class="number">100.0</span>;</span><br><span class="line">        Double i3 = <span class="number">200.0</span>;</span><br><span class="line">        Double i4 = <span class="number">200.0</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出结果：</span></span><br><span class="line"><span class="comment">* false</span></span><br><span class="line"><span class="comment">* false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">        Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">        Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出结果：</span></span><br><span class="line"><span class="comment">* true</span></span><br><span class="line"><span class="comment">* true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上结果参照Boolean类的源码也会一目了然：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>以及TRUE 和 FALSE的定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment"> * value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> Boolean&#125; object corresponding to the primitive</span></span><br><span class="line"><span class="comment"> * value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于Java装拆箱与包装类型的学习&quot;&gt;&lt;a href=&quot;#关于Java装拆箱与包装类型的学习&quot; class=&quot;headerlink&quot; title=&quot;关于Java装拆箱与包装类型的学习&quot;&gt;&lt;/a&gt;关于Java装拆箱与包装类型的学习&lt;/h2&gt;&lt;h3 id=&quot;Java的包装类&quot;&gt;&lt;a href=&quot;#Java的包装类&quot; class=&quot;headerlink&quot; title=&quot;Java的包装类&quot;&gt;&lt;/a&gt;Java的包装类&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)，有些地方也翻译为外覆类或数据类型类，如下表所示：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://thecoy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>2017-05-06diary</title>
    <link href="http://thecoy.github.io/2017/05/06/2017-05-06diary/"/>
    <id>http://thecoy.github.io/2017/05/06/2017-05-06diary/</id>
    <published>2017-05-06T11:46:55.000Z</published>
    <updated>2018-11-12T14:50:26.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017-05-06"><a href="#2017-05-06" class="headerlink" title="2017-05-06"></a>2017-05-06</h2><p>之前很久就想弄这个Blog了，但一直各种事情缠身，终于花了近一天的时间搭了个雏形，非常感谢<strong>Litten</strong>提供的这个主题 <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">yilia</a>，很喜欢它，虽然不是一枚前端猿，但其实发现能够自己折腾折腾做些好玩又好看的东西也还蛮有意思的，所以后面也还是会继续不断地折腾，向大神学习，一点点的进步！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2017-05-06&quot;&gt;&lt;a href=&quot;#2017-05-06&quot; class=&quot;headerlink&quot; title=&quot;2017-05-06&quot;&gt;&lt;/a&gt;2017-05-06&lt;/h2&gt;&lt;p&gt;之前很久就想弄这个Blog了，但一直各种事情缠身，终于花了近一天的时间搭了个
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://thecoy.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
